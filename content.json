{"pages":[{"title":"","text":"404 - arao'blog *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,ו;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} .plan{color: black;background: white;font-size: 30px; margin-top: 20px;} .plan:hover{color: white;background: black;font-size: 30px;} #gg { position: absolute; width: 654px; height: 470px; left: 50%; top: 50%; margin-left: -377px; margin-top: 0px; }","link":"/404.html"},{"title":"关于我","text":"前言 该网站为个人技术博客网站, 是我模仿别人的(Github: https://github.com/CoderTitan) 因为我个人也比较喜欢逛一个技术论坛和博客, 所以自己也经常写点东西, 以后也会继续坚持下去 个人简介 iOS开发工程师 学习历程 C 、 C++ Objective-C 、 Swift HTML5、JavaScript、CSS Python 联系我 简书: https://www.jianshu.com/u/cda07f394e73 微博: https://weibo.com/3935895096677821 Github: https://github.com/arthurtop 掘金: https://juejin.im/user/5ac98725f265da23830b263b 网易云音乐","link":"/about/index.html"}],"posts":[{"title":"Mac软件大全","text":"斯蒂芬的博客 苹果网PC6 爱情守望者","link":"/2018/12/20/Mac软件大全/"},{"title":"Swift仿网易新闻首页左右滑动切换页面","text":"顶部标题左右滑动切换控制器是一种非常用的左右滚动切换效果,几乎每一个APP都有用到,在这里介绍一下我自己封装的一个Swift版本的简单框架;代码中注释相对详细,故文中没有做过多的解释;废话不多少,直接上效果图: 一.框架介绍github地址 1234567TJTitleStyle.swift //控制框架所有显示样式的参数值TJTitleView.swift //顶部标题的处理viewTJContentView.swift //处理所有控制器的viewTJPageView.swift //控制整体框架的总试图View TJTitleStyle.swift1234567891011121314151617181920212223242526272829303132333435363738/// 是否是滚动的Titlevar isScrollEnable : Bool = false/// 普通Title颜色var normalColor : UIColor = UIColor(r: 0, g: 0, b: 0)/// 选中Title颜色var selectedColor : UIColor = UIColor(r: 255, g: 127, b: 0)/// Title字体大小var font : UIFont = UIFont.systemFont(ofSize: 14.0)/// 滚动Title的字体间距var titleMargin : CGFloat = 20/// title的高度var titleHeight : CGFloat = 44/// 是否显示底部滚动条var isShowBottomLine : Bool = false/// 底部滚动条的颜色var bottomLineColor : UIColor = UIColor.orange/// 底部滚动条的高度var bottomLineH : CGFloat = 2/// 是否进行缩放var isNeedScale : Bool = falsevar scaleRange : CGFloat = 1.2/// 是否显示遮盖var isShowCover : Bool = false/// 遮盖背景颜色var coverBgColor : UIColor = UIColor.lightGray/// 文字&amp;遮盖间隙var coverMargin : CGFloat = 5/// 遮盖的高度var coverH : CGFloat = 25/// 设置圆角大小var coverRadius : CGFloat = 12 TJPageCollectionLayout.swift自定义布局 代码如下,注释比较详尽,不做赘述 123456789101112131415161718192021222324252627282930313233343536// 在该方法中设定一些必要的layout的结构和初始需要的参数override func prepare() { super.prepare() //0.计算item的宽度和高度 let itemW = ((collectionView?.bounds.width)! - sectionInset.left - sectionInset.right - minimumInteritemSpacing * CGFloat(cols - 1)) / CGFloat(cols) let itemH = ((collectionView?.bounds.height)! - sectionInset.top - sectionInset.bottom - minimumLineSpacing * CGFloat(rows - 1)) / CGFloat(rows) //1.获取一共多少个组 let sectionCount = collectionView!.numberOfSections //2.获取每个组中有多少个item var prePageCount : Int = 0 //页数 for i in 0..&lt;sectionCount { let itemCount = collectionView!.numberOfItems(inSection: i) for j in 0..&lt;itemCount { //2.1获取cell对应的indexPath let indexpath = IndexPath(item: j, section: i) //2.2根据indexPath创建UICollectionViewLayoutAttributes let attr = UICollectionViewLayoutAttributes(forCellWith: indexpath) // 2.3.计算j在该组中第几页 let page = j / (cols * rows) let index = j % (cols * rows) //2.4设置attrs的frame let itemY = sectionInset.top + (itemH + minimumLineSpacing) * CGFloat(index / cols) let itemX = CGFloat(prePageCount + page) * collectionView!.bounds.width + sectionInset.left + (itemW + minimumInteritemSpacing) * CGFloat(index % cols) attr.frame = CGRect(x: itemX, y: itemY, width: itemW, height: itemH) //2.5加入到数组中 cellAttrs.append(attr) } prePageCount += (itemCount - 1) / (cols * rows) + 1 } //计算最大宽度 maxWidth = CGFloat(prePageCount) * collectionView!.bounds.width} TJPageCollectionView.swift 创建collectionView显示布局内容,设置代理方法和对外暴露的方法 代理方法123456789101112131415protocol TJPageCollectionViewDateSource : class { //返回section的个数 func numberOfSections(in pageCollectionView : TJPageCollectionView) -&gt; Int //返回每个section中item的个数 func pageCollectionView(_ collectionView : TJPageCollectionView, numberOfItemsInSection section : Int) -&gt; Int //cell func pageCollectionView(_ pageCollectionView : TJPageCollectionView, _ collectionView : UICollectionView, cellForItemAt indexPath : IndexPath) -&gt; UICollectionViewCell}protocol TJPageCollectionViewDelegate : class { //cell点击事件处理 func pageCollectionView(_ pageCollectionView : TJPageCollectionView, didSelectorItemAt indexPath : IndexPath)} 二.首页左右滑动调用方法1.设置显示样式1234567let style = TJTitleStyle()//是否可以滚动style.isScrollEnable = true//是否显示下划线style.isShowBottomLine = true//是否显示遮挡试图viewstyle.isShowCover = true 2.初始化方法123456789101112/**初始化方法* frame : 坐标* titles : 标题数组* style : 样式* childVcs : 自控制器数组* parentVc : 父控制器*/let pageView = TJPageView(frame: frame, titles: titles, style: style, childVcs: childVcs, parentVc: self)view.addSubview(pageView) 三.底部类似表情键盘布局调用方法1.初始化12345678910111213141516171819202122// 1.设置显示样式let style = TJTitleStyle()style.isShowBottomLine = true//2.设置cell布局Layoutlet layout = TJPageCollectionLayout()layout.cols = 7 // 列layout.rows = 3 // 行layout.minimumLineSpacing = 0layout.minimumInteritemSpacing = 0layout.sectionInset = UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10)//3.创建collectionViewlet pageCollection = TJPageCollectionView(frame: CGRect(x: 0, y: UIScreen.main.bounds.height - 250, width: UIScreen.main.bounds.width, height: 250), style: style, titles: [\"普通\", \"粉丝\"], isTitleInTop: false, layout: layout)pageCollection.delegate = selfpageCollection.dataSource = self//4.注册cellpageCollection.register(nib: UINib(nibName: \"EmoticonViewCell\", bundle: nil), identifier: kEmoticonCellID)//5.添加到视图中view.addSubview(pageCollection) 2.遵循协议12345678910111213141516171819202122//MARK: TJCollectionViewDateSourceextension NextViewController : TJPageCollectionViewDateSource{ func numberOfSections(in pageCollectionView: TJPageCollectionView) -&gt; Int { return 5 } func pageCollectionView(_ collectionView: TJPageCollectionView, numberOfItemsInSection section: Int) -&gt; Int { return 40 } func pageCollectionView(_ pageCollectionView: TJPageCollectionView, _ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell { let cell = collectionView.dequeueReusableCell(withReuseIdentifier: kEmoticonCellID, for: indexPath) as! EmoticonViewCell return cell }}//MARK: TJPageCollectionViewDelegateextension NextViewController : TJPageCollectionViewDelegate{ func pageCollectionView(_ pageCollectionView: TJPageCollectionView, didSelectorItemAt indexPath: IndexPath) { print(indexPath) }} 框架代码中可能还有不足之处,还望大神多多指教. 菜鸟一枚,多多交流. github地址","link":"/2017/06/12/Swift仿网易新闻首页左右滑动切换页面/"},{"title":"Realm在iOS中的简单使用","text":"记录一些iOS 项目运行时的错误 把所有错误累计起来，已被以后查看 ##一、项目运行不了Failed to initiate service connection to simulator Error returned in reply: Connection invalid 解决办法：需要关闭所有不同版本的xcode还有模拟器，重新打开运行就行 ##二、添加文件或者第三方库出错linker command failed with exit code 1 (use -v to see invocation) 1、首先排查项目中是否有名字重复的文件; 结合我的以上的报错情况,查看项目中是否不止一个ViewController文件 2、检查是否在#import头文件的时候,错把.h写成了.m 通过Xcode的过滤查询功能,我很很快就修正了错误。 ##三、引入ARC库iOS 报错：cannot create weak reference in file using解决办法：点击工程启动文件 - TARGETS -Build Settings - 在下方搜索框搜索weak - 在Apple LLVM 8.0 - Language - Objective C选项下边 - 把Weak Reference in Manual Retain Release选项改成YES即可。","link":"/2018/08/10/iOS项目运行错误集锦/"},{"title":"iOS9之UIStackView的使用","text":"苹果在iOS9新增了一个简易的布局控件UIStackView,它是一个基于 Auto Layout 的抽象层从而使布局属性的创建简单化,它可以将一组 UIView 视图进行垂直或水平方向的排列。 UIStackView 既可以用代码编写也可以在 Interface Builder 中设计(简易xib更方便适用)。 你可以在一个主 UIStackView 中嵌套 UIStackView 从而让视图精确放置到相应的位置 下面就具体介绍一下UIStackView的一些方法和属性 一.方法1.初始化数组12345678//OC中- (instancetype)initWithArrangedSubviews:(NSArray&lt;__kindof UIView *&gt; *)views;//Swiftlet stackView1 = UIStackView(arrangedSubviews: subViews) 2.添加子视图12345678//OC- (void)addArrangedSubview:(UIView *)view;//SwiftstackView.addArrangedSubview(UIView) 3.移除子视图12345678//OC- (void)removeArrangedSubview:(UIView *)view;//SwiftstackView1.removeArrangedSubview(UIView) 4.根据下标插入子视图12345678//OC- (void)insertArrangedSubview:(UIView *)view atIndex:(NSUInteger)stackIndex;//SwiftstackView1.insertArrangedSubview(UIView, atIndex: Int) 二.属性1.布局方向123456789101112stackView.axis = .Horizontal/**************/Horizontal -&gt; UILayoutConstraintAxisHorizontal水平方向布局Vertical -&gt; UILayoutConstraintAxisVertical垂直方向布局 2.内容物填充样式123456789101112131415161718192021222324stackView.distribution = .FillEqually/****************/Fill -&gt; UIStackViewDistributionFill填充整个UIStackView，并且根据内部子视图尺寸对子视图尺寸进行动态调整。Fill Equally -&gt; UIStackViewDistributionFillEqually根据视图大小平均分配UIStackView尺寸，等比例填充UIStackView，过程中会根据分配的大小改变子视图尺寸。Fill Proportionally -&gt; UIStackViewDistributionFillProportionally根据之前的比例填充UIStackView。Equal Spacing -&gt; UIStackViewDistributionEqualSpacing填充整个UIStackView，子视图没有占满UIStackView将会用空白平均填充子视图中间的间距，超出UIStackView将会根据arrangedSubviews数组下标压缩子视图。Equal Centering -&gt; UIStackViewDistributionEqualCentering平均分配子视图得到每个视图的中心点，使用这个中心点来布局每个子视图，并且保持spacing距离，超出将会重新布局子视图，并压缩部分子视图。 3.视图填充样式123456789101112131415161718192021222324252627282930313233343536stackView.alignment = .Fill/****************/Fill -&gt; UIStackViewAlignmentFill视图纵向填充Top -&gt; UIStackViewAlignmentTop视图向上对其(适用于Horizontal模式)Center -&gt; UIStackViewAlignmentCenter视图居中对其Bottom -&gt; UIStackViewAlignmentBottom视图向下对其(适用于Horizontal模式)First Baseline -&gt; UIStackViewAlignmentFirstBaseline根据上方基线布局所有子视图的y值(适用于Horizontal模式)Last Baseline -&gt; UIStackViewAlignmentLastBaseline根据下方基线布局所有子视图的y值(适用于Horizontal模式)trailing -&gt; UIStackViewAlignmentTrailing视图向左对齐(适用于Vertical模式)leading -&gt; UIStackViewAlignmentLeading视图向右对齐(适用于Vertical模式) 4.子控件之间最小距离123456stackView.spacing = 0/****************/spacing -&gt; CGFloat spacing 5.基线相对布局12public var baselineRelativeArrangement: Bool 如果YES，则从顶视图的最后基线到底视图的顶部测量两个视图之间的垂直间距。 6.边界相对布局12public var layoutMarginsRelativeArrangement: Bool 决定了 stack 视图平铺其管理的视图时是否要参照它的布局边距，选中 Layout Margins Relative 将相对于标准边界空白来调整subview位置 ##Xib创建 择UIStackView控件直接拖到XIB中。可以选择Horizontal和Vertical两个方向的UIStackView，也可以在拖到XIB中之后手动修改。 父视图可以将UIStackView作为子视图来进行多层UIStackView嵌套，这也是苹果推荐的做法。 打开右侧设置面板来设置UIStackView的一些对应属性，达到更好的布局效果。 除了上面的方法也可以在XIB中直接选择多个View，然后点击右下方的Stack按钮，系统会自动推断布局方式,平均分配空间布局，帮我们自动布局子视图，我们可以在系统布局之后在手动进行调整。 作为一枚小菜鸟,不足之处还望大家多多指正,互相学起,共同进步!","link":"/2017/06/10/iOS9之UIStackView的使用/"},{"title":"SwiftLint代码规范属性说明03","text":"这篇文章是继前两篇文章的继续更新 Xcode代码规范之SwiftLint配置–这篇文章对SwiftLint进行了简单介绍和针对Xcode的相关配置 SwiftLint代码规范属性说明01–这里介绍了上半部分的相关属性的介绍 SwiftLint代码规范属性说明02–这里介绍了上半部分的相关属性的介绍 下面来具体介绍一下SwiftLint的其他的代码规则的相关说明 规则101: switch_case_alignmentswitch-case语句中switch和case应该垂直对齐 识别码 默认是否启用 是否支持自动更正 类型 switch_case_alignment 启用 no style 代码示例: 1234567891011121314151617//应该是这样switch someBool {case true: // case 1 print('red')case false: if case let .someEnum(val) = someFunc() { print('blue') }}//而不是这样switch someBool { ↓case true: print('red') ↓case false: print('blue')} 规则102: switch_case_on_newline在switch语法里， case应该总是在一个新行上面 识别码 默认是否启用 是否支持自动更正 类型 switch_case_on_newline 启用 no idiomatic 代码示例: 12345678910111213141516/// swiftlint表示会触发warning switch type { case .value1: print(\"1\")...................在同一行错 case .value2: print(\"2\")...................在同一行错 default: print(\"3\")...................在同一行错 } /// 不会触发warning switch type { case .value1: print(\"1\") case .value2: print(\"2\") default: print(\"3\") } 规则103: syntactic_sugarswiftlint推荐使用速记语法糖， 例如 [Int] 代替 Array, 强烈建议推荐使用 识别码 默认是否启用 是否支持自动更正 类型 syntactic_sugar 启用 no idiomatic 代码示例: 1234567/// 触发warning let myArray: Array&lt;Int&gt; = [1, 2, 3] print(myArray) /// 正确写法，不会触发warning let myArray: [Int] = [1, 2, 3] print(myArray) 规则104: todoTODO 和 FIXME 应该避免使用， 使用“notaTODO 和 notaFIXME”代替。另外， 和 MARK 标记不同的是， “notaTODO 和 notaFIXME”没有空格要求 识别码 默认是否启用 是否支持自动更正 类型 todo 启用 no lint 规则105: trailing_closure关于闭包中{}的使用, 推荐使用尾随闭包的语法 识别码 默认是否启用 是否支持自动更正 类型 trailing_closure 未启用 no style 代码示例: 1234567//推荐使用foo.map { $0 + 1 }foo.reduce(0) { $0 + 1 }//不推荐使用foo.map({ $0 + 1 })↓foo.reduce(0, combine: { $0 + 1 }) 规则106: trailing_comma…这个属性主要针对数组和字典最后一个元素, 不建议在最后一个元素会面加逗号 识别码 默认是否启用 是否支持自动更正 类型 trailing_comma 启用 yes style 代码示例: 1234567/// 数组这样写是没有任何问题的, 但是最后一个元素3后面加了一个逗号“,”尽管这样不会报错，但是这会让程序的可读性变差let ages = [1, 2, 3,]let person = [\"XingYun\": 98, \"JinGang\": 128, \"LangKe\": 18,]/// 使用swiftlint的trailing_comma规则后，就会报warning， 所以正确的写法不应该加上这个“,”let ages = [1, 2, 3]let person = [\"XingYun\": 98, \"JinGang\": 128, \"LangKe\": 18] 规则107: trailing_newline文件（属性、方法）结束的的时候（“}”之前）， 应该有一个空格新行，但这里要注意的是 识别码 默认是否启用 是否支持自动更正 类型 trailing_newline 启用 yes style 代码示例: 1234567891011121314151617/// 空一行，不会触发警告nonTriggeringExamples: [ \"let a = 0\\n\"],/// 下面会触发警告triggeringExamples: [ \"let a = 0\", /// 不空行，会触发警告（实际上，我试过，不会触发警告） \"let a = 0\\n\\n\" /// 空两行， 会触发警告（实际上，我试过，会触发警告，但是触发的是vertical_whitespace警告而不是trailing_newline）],/// 说说这里，它要求改正为都空一行，虽然这样code看起来很轻松，但如果定义变量或常量太多，就太分散了（值得说的是，就算不空行也不会触发trailing_newline, 应该刚才也已经说了，这个属性只是说“应该”，而不是必须）corrections: [ \"let a = 0\": \"let a = 0\\n\", \"let b = 0\\n\\n\": \"let b = 0\\n\", \"let c = 0\\n\\n\\n\\n\": \"let c = 0\\n\"] 规则108: trailing_semicolon尽管在变量或常量赋值之后加不加分号在swift中没有硬性的要求，但是为了使code style更swift化，所以尽量或者绝对不要加“;” 识别码 默认是否启用 是否支持自动更正 类型 trailing_semicolon 启用 yes idiomatic 规则109: trailing_whitespace函数方法结束后,不建议添加空格行, 和vertical_whitespace貌似有冲突 识别码 默认是否启用 是否支持自动更正 类型 trailing_whitespace 启用 yes style 代码示例: 12345678910111213/// 下面这个例子不会触发警告，但是一旦其中有一个空行就会触发警告trailing_whitespace, 这和vertical_whitespace实质上有些冲突，vertical_whitespace要求两行code之间不超过1行，要么没有空行，要么只有1行，而trailing_whitespace要求没有空行！！！class ViewController: UIViewController {override func viewDidLoad() { super.viewDidLoad() let a = 0 let b = 1 let c = 2}func chenlong() -&gt; Void { let a = 0 print(a)}} 规则110: type_body_length类型体长度。类型体长度不应该跨越太多行， 超过200行给warning，超过350行给error。一般是大括号或者括号内, 比如定义一个enum或struct 识别码 默认是否启用 是否支持自动更正 类型 type_body_length 启用 no metrics 规则111: type_name…类型名， 类型名应该只包含字母数字字符， 并且以大写字母开头，长度在3-40个字符 识别码 默认是否启用 是否支持自动更正 类型 type_name 启用 no idiomatic 规则112: unneeded_break_in_switch在switch-case语句中, 有方法调用或操作时,避免使用break语句 识别码 默认是否启用 是否支持自动更正 类型 unneeded_break_in_switch 启用 no idiomatic 代码示例: 123456789101112131415161718192021//不会触发warningswitch foo {case .bar: break}switch foo {default: break}switch foo {case .bar: something()}//会触发warningswitch foo {case .bar://这里已经有方法调用了 something() ↓break} 规则113: unneeded_parentheses_in_closure_argument…在定义或使用闭包时,闭包参数不建议使用括号() 识别码 默认是否启用 是否支持自动更正 类型 unneeded_parentheses_in_closure_argument 未启用 yes style 代码示例: 12345678//建议let foo = { (bar: Int) in }let foo = { bar, _ in }let foo = { bar in }//不建议call(arg: { ↓(bar) in })call(arg: { ↓(bar, _) in }) 规则114: unused_closure_parameterswiftlint建议最好把不使用的闭包参数使用 “_”代替 识别码 默认是否启用 是否支持自动更正 类型 unused_closure_parameter 启用 yes lint 代码示例: 123456789101112131415//不会触发warning[1, 2].map { number in number + 1 }[1, 2].map { _ in 3 }//会触发warning[1, 2].map { ↓number in return 3}[1, 2].map { ↓number in return numberWithSuffix} 规则115: unused_enumerated在for遍历数组时, 如有未使用的索引,不建议使用.enumerated() 识别码 默认是否启用 是否支持自动更正 类型 unused_enumerated 启用 no idiomatic 代码示例: 12345678910//不会触发warningfor (idx, foo) in bar.enumerated() { }for (_, foo) in bar.enumerated().something() { }for (_, foo) in bar.something() { }//会触发warningfor (↓_, foo) in bar.enumerated() { }for (↓_, foo) in abc.bar.enumerated() { }for (↓_, foo) in abc.something().enumerated() { }for (idx, ↓_) in bar.enumerated() { } 规则116: unused_optional_binding在使用if判断某变量是否为nil的时候, 不建议使用下划线(_) 识别码 默认是否启用 是否支持自动更正 类型 unused_optional_binding 启用 no style 代码示例: 123456789//不会触发warningif let bar = Foo.optionalValue {}//会触发warningif let ↓_ = Foo.optionalValue {}if let a = Foo.optionalValue, let ↓_ = Foo.optionalValue2 {} 规则117: valid_ibinspectable@IBInspectable在swiftlint中的使用需要注意， 第一必须是变量， 第二必须要有指定的类型，如果指定的类型是可选类型或者隐式类型，则目前官方只支持以下几种类型： String, NSString, UIColor, NSColor, UIImage, NSImage. 识别码 默认是否启用 是否支持自动更正 类型 valid_ibinspectable 启用 no lint 代码示例: 12345678910111213/// 指定为变量var， 类型为String？和String！@IBInspectable private var yyy: String?@IBInspectable private var zzz: String!/// 如果写成这样，编译能通过，但是会触发警告, 因为swiftlint暂不支持Int可选和隐式类型:@IBInspectable private var dddl: Int!@IBInspectable private var eeel: Int?/// 如果指定的类型不是可选类型， 就应该初始化，否则系统不允许，会报错所在的类没有初始化对：@IBInspectable private var counts: Int = 0系统报错：@IBInspectable private var counts: Int 规则118: vertical_parameter_alignment垂直方向上的参数对齐。当函数参数有多行的时候， 函数参数在垂直方向上应该对齐（参数换行的时候左边对齐） 识别码 默认是否启用 是否支持自动更正 类型 vertical_parameter_alignment 启用 no style 代码示例: 12345678910//不会触发warningfunc validateFunction(_ file: File, kind: SwiftDeclarationKind, dictionary: [String: SourceKitRepresentable]) { } func validateFunction(_ file: File, kind: SwiftDeclarationKind, dictionary: [String: SourceKitRepresentable]) -&gt; [StyleViolation]//会触发warningfunc validateFunction(_ file: File, kind: SwiftDeclarationKind, ↓dictionary: [String: SourceKitRepresentable]) { } 规则119: vertical_parameter_alignment_on_call当调用多个参数的函数时,如果参数多行显示,则应该垂直对齐 识别码 默认是否启用 是否支持自动更正 类型 vertical_parameter_alignment_on_call 未启用 no style 代码示例: 12345678910111213141516171819//不会触发warningfoo(param1: 1, param2: bar param3: false, param4: true)foo(param1: 1, param2: bar)foo(param1: 1, param2: bar param3: false, param4: true)//会触发warningfoo(param1: 1, param2: bar ↓param3: false, param4: true) foo(param1: 1, param2: bar ↓param3: false, param4: true) foo(param1: 1, param2: bar ↓param3: false, ↓param4: true) 规则120: vertical_whitespace垂直方向上的空格行，限制为一行（注释除外） 识别码 默认是否启用 是否支持自动更正 类型 vertical_whitespace 启用 yes style 代码示例: 1234567891011121314151617181920/// 没有空格， nonTriggerWarningoverride func viewDidLoad() { super.viewDidLoad() let aaa = 0} /// 有一行空格, nonTriggerWarningoverride func viewDidLoad() { super.viewDidLoad() let aaa = 0 ............................1}/// &gt;=2行，就会触发警告override func viewDidLoad() { super.viewDidLoad() let aaa = 0 .............................1 .............................2} 规则121: void_return多余的返回值为空， 在函数声明的时候，返回值为空是多余的。定义常量或者变量的时候可以 识别码 默认是否启用 是否支持自动更正 类型 void_return 启用 yes style 代码示例: 123456789/// 这个属性要求这样写， 返回值为空省略func XingYun() { print(\"titan\")}/// 这个属性要求别这样写，否则会有warning（但是我在swift 3.0上测试并没有触发warning）func XingYun() -&gt; Void { print(\"titan\")} 规则122: weak_delegate代理应该写成weak类型（弱代理）来避免循环引用 识别码 默认是否启用 是否支持自动更正 类型 weak_delegate 启用 no lint 代码示例: 123456789101112131415161718192021222324252627282930/// 1.1 编译通过class Langke { var chenlong: NSObjectProtocol?}/// 1.2 编译通过，但是触发swiftlint的 weak_delegate警告， 原因是变量名 myDelegate 中有 delegate 关键字，这属于名字滥用class Langke { var myDelegate: NSObjectProtocol?}/// 1.3 编译通过， 不会触发警告， 原因是在 var 关键字前面加了 weakclass Langke { weak var myDelegate: NSObjectProtocol?}/// 2.1 编译通过，但是触发 weak_delegate 警告，原因是 scrollDelegate 中 Delegate 放在了最后， 被理解成了代理class Langke { var scrollDelegate: UIScrollViewDelegate?}/// 2.2 编译通过， 既然变量名被理解成了代理， 那为了类似防止循环引用， 应该加关键字 weakclass Langke { weak var scrollDelegate: UIScrollViewDelegate?}/// 编译通过， 不会触发警告， 因为delegate放在了前面， 没有被理解成代理class Langke { var delegateScroll: UIScrollViewDelegate?} 规则123: xctfail_message单元测试中,XCTFail调用应该包括声明描述 识别码 默认是否启用 是否支持自动更正 类型 xctfail_message 启用 no idiomatic 规则124: yoda_condition执行判断语句时, 变量名应该放在运算符的左边 识别码 默认是否启用 是否支持自动更正 类型 yoda_condition 未启用 no lint 代码示例: 123456789101112//不会触发warningif foo == 42 {}if foo &lt;= 42.42 {}guard foo &gt;= 42 else { return }guard foo != \"str str\" else { return }//会触发warning↓if 42 == foo {}↓if 42.42 &gt;= foo {}↓guard 42 &lt;= foo else { return }↓guard \"str str\" != foo else { return }↓while 10 &gt; foo { } 文中如有不足之处请多指教 持续更新中…..","link":"/2018/03/10/SwiftLint代码规范属性说明03/"},{"title":"Xcode代码规范之SwiftLint配置","text":"前言 最近公司大佬考虑将项目代码规范化, 然而自Xcode9之后,Xcode的插件基本处于废弃的状态大部分插件都是在一年前就停止更新了; 于是在谷歌找到了一款强大的代码规范工具SwiftLint SwiftLint是 Realm 推出的一款 Swift 代码规范检查工具, SwiftLint 基于 Github 公布的 Swift 代码规范进行代码检查，并且能够很好的和 Xcode 整合 Github 公布的 Swift 代码规范–原文 Github 公布的 Swift 代码规范–中文 配置好所有的设置之后，在 Xcode 中执行编译时，SwiftLint 会自动运行检查，不符合规范的代码会通过警告或者 红色错误 的形式指示出来 支持自定义规则,可禁用或者开启某一些规则 安装SwiftLint SwiftLint目前有三种安装方式可供选择,可以根据自己的项目需要自行选择 安装全局配置(Homebrew 安装)Homebrew Homebrew, Mac系统的包管理器，用于安装NodeJS和一些其他必需的工具软件, 输入以下代码安装: 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 译注：在Max OS X 10.11（El Capitan)版本中，homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复： 1sudo chown -R `whoami` /usr/local Homebrew 会自动安装最新版本 打开终端输入以下代码: 1brew install swiftlint 安装成功,如下图所示: 使用 CocoaPods 安装 这种方式只能针对单个项目有效,如果你想要针对不同的项目使用不同的SwiftLint 版本，这是一种很好的解决方案 需要注意的是使用这种方案会将整个SwiftLint以及他的依赖包的完整资源文件都安装到 Pods/ 目录中去，所以在使用版本管理工具比如 git/svn 时要注意设置忽略相关目录 CocosPods安装和安装第三方框架一样 在根目录创建Podfile 1pod &apos;SwiftLint&apos; 使用安装包SwiftLint 还支持使用 pkg 安装包进行安装，在官方的 Github 页面可以找到最新发布的安装包 查看SwiftLint的全部命令 等待安装完成，在终端输入 swiftlint help 可以查看所有可用的命令： 各个命令注释 1234567891011121314//查看所有命令swiftlint help//忽略空格导致的警告和错误swiftlint autocorrect//输出所有的警告和错误swiftlint lint//查看所有可获得的规则以及对应的 IDswiftlint rules//产看当前版本号swiftlint version 我们将目录切换到工程的根目录之下，然后敲击如下命令: 1swiftlint autocorrect 然后我们就会发现，所有的空格符Warning都消失了。这都得益于我们刚刚所进行的命令行操作，它会将已知的能够自动修复的Error和Warning都自动修复，大大的减轻了我们的工作量。 SwiftLint的使用 安装完成后,需要在Xcode中配置相关设置,才能使 SwiftLint 在 Xcode 中自动检测代码规范。配置也很简单，只需要在 Xcode 的 Build Phases 中新建一个 Run Script Phase 配置项，在里面添加相关代码后,编译即可! 配置代码添加步骤 需要将相关脚本添加到红色框内 1. 全局安装脚本添加方式 12345if which swiftlint &gt;/dev/null; then swiftlintelse echo &quot;warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint&quot;fi 2. CocoaPods安装脚本添加 1&quot;${PODS_ROOT}/SwiftLint/swiftlint&quot; 这里其实是设置了一个自动编译脚本，每次运行编译都会自动执行这个脚本 如果正确安装了 SwiftLint，就会执行 SwiftLint 中的代码规范检查，如果没有安装，脚本会抛出一个没有安装 SwiftLint 并提示下载的警告，方便提醒团队团队中没有安装的成员。 当然，你也可以设置为强制要求安装，这时如果没有安装则无法通过编译。只需要在脚本中1echo &quot;warning: ...&quot; 之后添加一行代码： 1exit 1 这样一来，如果没有安装 SwiftLint，编译时会直接抛出一个编译错误而非警告，提示需要安装 SwiftLint。 3. 配置完成后,command+B编译 如果你的是正在开发中的项目, 你可能会发现你的项目提示999+的黄色警告和999+的红色错误 甚至你会发现甚至一些空格和一些系统的方法和注释也会报错或者警告 SwiftLint默认方法名或者注释不得超过120个字符 Swift Lint 在完成上述操作之后，便已经生效。但是，如果觉得默认的风格过于严格，或者项目组有另外的要求，Swift Lint 也可以定制相应的风格，或者禁用某些规则。 SwiftLint 的全部规则可以在：Source/SwiftLintFramework/Rules 目录内找到 自定义配置 当你编译过项目后,看到999+的警告和错误,是不是第一反应就是要放弃了,其实不然 仔细看一下具体的错误，会发现好多都是第三方库的代码规范问题，而且好多问题的级别被设置成为了 error 第三方库的代码规范问题,这个锅我们可不能背 这里我们可以做一些配置，让 SwiftLint 在做代码规范检查的时候自动忽略 CocoaPods、Carthage 等包管理器引入的第三方库（当然，手动导入的第三方库也能设置忽略） 创建配置文件 首先需要在项目的根目录下新建一个名为 .swiftlint.yml 的配置文件 打开终端, cd 到项目根目录下 输入: touch .swiftlint.yml 执行完该命令后, 在文件夹中你可能找不到该yml格式文件,那是因为文件被隐藏了 关于隐藏/显示隐藏文件(命令一样): command + shift + . 下面我们来认识一下主要的几个配置选项 12345678910111213141516disabled_rules: # 禁用指定的规则 - colon - comma - control_statementopt_in_rules: # 启用指定的规则 - empty_count - missing_docs # 可以通过执行如下指令来查找所有可用的规则: # swiftlint rulesincluded: # 执行 linting 时包含的路径。如果出现这个 `--path` 会被忽略。 - Sourceexcluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。 - Carthage - Pods - Source/ExcludedFolder - Source/ExcludedFile.swift 在代码中关闭某个规则可以通过在一个源文件中定义一个如下格式的注释来关闭某个规则：1// swiftlint:disable &lt;rule&gt; 在该文件结束之前或者在定义如下格式的匹配注释之前，这条规则都会被禁用：1// swiftlint:enable &lt;rule&gt; 例如:12345678// swiftlint:disable opening_bracefunc initTakeScreenshot(launchOptions: [AnyHashable: Any]?){ // swiftlint:enable opening_brace if let options = launchOptions { let userInfo = options[UIApplicationLaunchOptionsKey.remoteNotification] NotificationCenter.default.post(name: Notification.Name.UIApplicationUserDidTakeScreenshot, object: userInfo) }} 规则关闭之前 规则关闭之后 也可以通过添加 :previous, :this 或者 :next 来使关闭或者打开某条规则的命令分别应用于前一行，当前或者后一行代码。 例如: 123456// swiftlint:disable:next force_castlet noWarning = NSNumber() as! Intlet hasWarning = NSNumber() as! Intlet noWarning2 = NSNumber() as! Int // swiftlint:disable:this force_castlet noWarning3 = NSNumber() as! Int// swiftlint:disable:previous force_cast 忽略引入的第三方库 1). 忽略CocoaPods导入的第三方库 12excluded: - Pods 2). excluded 配置项用来设置忽略代码规范检查的路径，可以指定整个文件夹 比如如果你的项目使用 Carthage 管理第三方库的话，可以将 Carthage 目录添加到忽略列表： 123excluded: - Pods - Carthage 3). 指定精确路径下的文件，通过 - xxxx 的形式列在下面就可以了 123excluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。 - Source/ExcludedFolder - Source/ExcludedFile.swift 嵌套配置SwiftLint 支持通过嵌套配置文件的方式来对代码分析过程进行更加细致的控制。 在你的根 .swiftlint.yml 文件里设置 use_nested_configs: true 值。 在目录结构必要的地方引入额外的 .swiftlint.yml 文件。 每个文件被检查时会使用在文件所在目录下的或者父目录的更深层目录下的配置文件。否则根配置文件将会生效。 excluded，included，和 use_nested_configs 在嵌套结构中会被忽略。 自动更正 SwiftLint 可以自动修正某些错误，磁盘上的文件会被一个修正后的版本覆盖。 请确保在对文件执行 swiftlint autocorrect 之前有对它们做过备份，否则的话有可能导致重要数据的丢失。 因为在执行自动更正修改某个文件后很有可能导致之前生成的代码检查信息无效或者不正确，所以当在执行代码更正时标准的检查是无法使用的。 最后贴上官方示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849disabled_rules: # 执行时排除掉的规则 - colon - comma - control_statementopt_in_rules: # 一些规则仅仅是可选的 - empty_count - missing_docs # 可以通过执行如下指令来查找所有可用的规则: # swiftlint rulesincluded: # 执行 linting 时包含的路径。如果出现这个 `--path` 会被忽略。 - Sourceexcluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。 - Carthage - Pods - Source/ExcludedFolder - Source/ExcludedFile.swift# 可配置的规则可以通过这个配置文件来自定义# 二进制规则可以设置他们的严格程度force_cast: warning # 隐式force_try: severity: warning # 显式# 同时有警告和错误等级的规则，可以只设置它的警告等级# 隐式line_length: 110# 可以通过一个数组同时进行隐式设置type_body_length: - 300 # warning - 400 # error# 或者也可以同时进行显式设置file_length: warning: 500 error: 1200# 命名规则可以设置最小长度和最大程度的警告/错误# 此外它们也可以设置排除在外的名字type_name: min_length: 4 # 只是警告 max_length: # 警告和错误 warning: 40 error: 50 excluded: iPhone # 排除某个名字variable_name: min_length: # 只有最小长度 error: 4 # 只有错误 excluded: # 排除某些名字 - id - URL - GlobalAPIKeyreporter: &quot;xcode&quot; # 报告类型 (xcode, json, csv, checkstyle) 附录: 原文链接：https://github.com/realm/SwiftLint/blob/master/README.md译文链接：https://github.com/realm/SwiftLint/blob/master/README_CN.md","link":"/2018/02/07/Xcode代码规范之SwiftLint配置/"},{"title":"iOS神技之动态更换APP的Icon图","text":"在iOS10.3系统发布之前, 众所周知, 在App Store上架的APP如果要更换Icon图, 只能更新版本替换; 这次苹果却在iOS10.3系统中加入了了更换应用图标的新功能，当应用安装后，开发者可以为应用提供多个应用图标选择。 用户可以自由的在这些图标之间切换，并及时生效。 这是因为 10.3 里引入了一个新的 API，它允许在 App 运行的时候，通过代码为 app 更换 icon 项目配置 虽然提供了更换的功能，但更换的 icon 是有限制的 它只能更换项目中提前添加配置好的Icon图 具体可参考demo–github项目地址 这里先看个效果 备选Icon 首先你需要将备选的Icon图添加到项目中, 注意: 图片不要放到Assets.xcassets, 而应该直接放到工程中, 不然可能导致更换Icon时, 找不到图片, 更换失败 在info.plist 的配置中，图片的文件名应该尽量不带 @2x/@3x 后缀扩展名，而让它自动选择 配置info.plist文件 在info.plist文件中，添加对应的CFBundleAlternateIcons的信息 这里也可以查看官方的相关介绍 Source Code添加方式如下 123456789101112131415161718192021222324252627282930313233343536373839 &lt;key&gt;CFBundleAlternateIcons&lt;/key&gt;&lt;dict&gt; &lt;key&gt;天天特价&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;天天特价&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UIPrerenderedIcon&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;小房子&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;小房子&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UIPrerenderedIcon&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;小猫&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;小猫&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UIPrerenderedIcon&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;邮件信息&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;邮件信息&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UIPrerenderedIcon&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt;&lt;/dict&gt; 注意事项: 虽然文档中写着「You must declare your app's primary and alternate icons using the CFBundleIcons key of your app's Info.plist file. 」，但经测试，CFBundlePrimaryIcon 可以省略掉。在工程配置 App Icons and Launch Image - App Icons Source 中使用 asset catalog（默认配置），删除 CFBundlePrimaryIcon 的配置也是没有问题的。 省略这个配置的好处是，避免处理 App icon 的尺寸。现在的工程中，大家一般都使用 asset catalog 进行 icon 的配置，而一个 icon 对应有很多尺寸的文件。省略 CFBundlePrimaryIcon 就可以沿用 Asset 中的配置。 如果想设置回默认 icon，在 setAlternateIconName 中传入 nil 即可 API调用下面我们看一下系统提供的三个API, 这里产看官方文档 123456789101112var supportsAlternateIcons: Bool//一个布尔值，指示是否允许应用程序更改其图标var alternateIconName: String?//可选图标的名称，在app的Info.plist文件中声明的CFBundleAlternateIcons中设置。//如果要显示应用程序的主图标alternateIconName 传nil即可，主图标使用CFBundlePrimaryIcon声明，CFBundleAlternateIcons与CFBundlePrimaryIcon两个key都是CFBundleIcons的子条目func setAlternateIconName(_ alternateIconName: String?, completionHandler: ((Error?) -&gt; Void)? = nil)//更改应用程序的图标//completionHandler: 当有结果的时候的回调//成功改变图标的的时候，error为nil，如果发生错误，error描述发生什么了。并且alternateIconName的值保持不变 具体的实现代码: 12345678910111213if #available(iOS 10.3, *) { //判断是否支持替换图标, false: 不支持 guard UIApplication.shared.supportsAlternateIcons else { return } //如果支持, 替换icon UIApplication.shared.setAlternateIconName(imageStr) { (error) in if error != nil { print(error ?? \"更换icon发生错误\") } else { print(\"更换成功\") } }} 消除alert弹窗 动态更换App图标会有弹框, 有时候这个弹框看上去可能会很别扭, 但是这个弹框是系统直接调用弹出的, 我们又如何消除呢 通过层级关系可以看到这个弹框就是一个UIAlertController, 并且是通过presentViewController:animated:completion:方法弹出的 所以可以考虑使用runtime, 拦截并替换该方法, 让更换icon的时候, 不弹 下面看一下具体代码: 123456789101112131415161718192021222324252627282930313233extension NoAlertChangeViewController { fileprivate func runtimeReplaceAlert() { DispatchQueue.once(token: \"UIAlertController\") { let originalSelector = #selector(present(_:animated:completion:)) let swizzledSelector = #selector(noAlert_present(_:animated:completion:)) let originalMethod = class_getInstanceMethod(NoAlertChangeViewController.self, originalSelector) let swizzledMethod = class_getInstanceMethod(NoAlertChangeViewController.self, swizzledSelector) //交换实现的方法 method_exchangeImplementations(originalMethod!, swizzledMethod!) } } @objc fileprivate func noAlert_present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -&gt; Swift.Void)? = nil) { //判断是否是alert弹窗 if viewControllerToPresent.isKind(of: UIAlertController.self) { print(\"title: \\(String(describing: (viewControllerToPresent as? UIAlertController)?.title))\") print(\"message: \\(String(describing: (viewControllerToPresent as? UIAlertController)?.message))\") // 换图标时的提示框的title和message都是nil，由此可特殊处理 let alertController = viewControllerToPresent as? UIAlertController if alertController?.title == nil &amp;&amp; alertController?.message == nil { //是更换icon的提示 return } else { //其他的弹框提示正常处理 noAlert_present(viewControllerToPresent, animated: flag, completion: completion) } } noAlert_present(viewControllerToPresent, animated: flag, completion: completion) }} 这里用到了DispatchQueue.once, 这个once是我对DispatchQueue加了一个扩展 在Swift4.0以后, static dispatch_once_t onceToken;这个已经不能用了 关于这方面的详细介绍, 大家可以看看我的这篇文章–升级Swift4.0遇到的坑- 支持不同尺寸的Icon 一个标准的Icon图集, 需要十几种尺寸, 比如: 20, 29, 40, 60等 对于 info.plist 中的每个 icon 配置，CFBundleIconFiles 的值是一个数组，我们可以在其中填入这十几种规格的图片名称。经测试: 文件的命名没有强制的规则，可以随意取， 数组中的文件名也不关心先后顺序。 总之把对应的文件名填进去即可，它会自动选择合适分辨率的文件（比如在 setting 中显示 icon 时，它会找到提供的数组中分辨率为 29pt 的那个文件）。 具体相关官方文档可参考, 官方介绍 首先, 针对不同的尺寸, 我们要有不同的命名, 具体参考下图 文件扩展名，如@2x,@3x，要么统一不写，那么系统会自动寻找合适的尺寸。 要写就需要把每张icon的扩展名写上，和上图的格式一样 代码中调用图片名, 更不需要加上尺寸: 1234567891011121314if #available(iOS 10.3, *) { //判断是否支持替换图标, false: 不支持 guard UIApplication.shared.supportsAlternateIcons else { return } //如果支持, 替换icon UIApplication.shared.setAlternateIconName(\"Sunday\") { (error) in //点击弹框的确认按钮后的回调 if error != nil { print(error ?? \"更换icon发生错误\") } else { print(\"更换成功\") } }} 具体可参考demo–github项目地址","link":"/2018/03/16/iOS神技之动态更换APP的Icon图/"},{"title":"升级Swift4.0遇到的坑","text":"并不是所有库都能做到及时支持Swift4.0，更何况是在现在连Xcode9也还是beta的状态 所以我们仅能做到将自己的业务代码（主工程代码）部分升级到Swift4.0，然后同时保留各种pod库在Swift3.2版本。 没办法，谁叫Swift4.0也还无法做到API兼容呢（但愿能在Swift5之前实现吧）。 至于我说的同时使用两个版本的Swift，这是没问题的，Xcode9支持在项目中同时使用Swift3.2和Swift4.0。 修改Swift版本指定主工程的Swift版本为4.0 修改pod库 在Podfile文件的最下方加入如下代码，指定pod库的Swift版本为3.2(这样会使得所有的第三方pod库的Swift版本都为3.2) 1234567post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings['SWIFT_VERSION'] = '3.2' end endend 主工程中的代码修改Swift3.2到Swift4.0的改变 1). Swift4.0中对于扩展的属性(包括实例属性、static属性、class属性)，都只能使用get方法，不可使用set方法 2). Swift4.0中不再允许复写扩展中的方法(包括实例方法、static方法、class方法) 比如:自定义的协议方法在extension中实现,若某个类遵循了该协议,其子类便不能重写该协议方法 解决的方法是: 在每个需要该协议的类里面都重新遵循该协议,实现协议方法 个人想到的办法,不知道有没有其他解决办法可以提供一下 3). swift3使用#selector指定的方法，只有当方法权限为private时需要加@objc修饰符，现在Swift4.0全都要加@objc修饰符 4). 自定义的protocol协议中,有optional修饰的非必须实现的方法,需要用@objc修饰 5). 字体方面的一些重命名 12345678910111213141516NSFontAttributeName --- .font//或者NSAttributedStringKey.fontNSForegroundColorAttributeName --- .foregroundColor//NSAttributedStringKey.foregroundColorNSStrikethroughStyleAttributeName --- .strikethroughStyle//NSAttributedStringKey.strikethroughStyle//字符串类型的,添加rawValueNSAttributedStringKey.font.rawValue//等等等等..........//大部分类似以下,涉及富文本的方法均已改为了NSAttributedStringKey类型addAttributes(_ attrs: [NSAttributedStringKey : Any] = [:], range: NSRange) 一些的报错问题“Closure cannot implicitly capture a mutating self parameter”错误 在struct中，如果我们在闭包中使用self，就会得到Closure cannot implicitly capture a mutating self parameter的错误提示。比如： 1234567891011struct RecordModel { /// 定义一个闭包 var action: (() -&gt; ())? var height = 10 self.action = { self.height = 20 //Closure cannot implicitly capture a mutating self parameter报错 }} 并且由于RecordModel的类型是struct，我们也没发在action闭包里添加截获列表。那么是不是就必须使用class了？答案是否定的。有两种方式可以解决这个问题。 方案一：为closure增加一个inout类型的参数12345678910struct RecordModel { /// 定义一个闭包 var action: ((_ inSelf: inout RecordModel) -&gt; ())? var height = 10 self.action = { (inSelf) in inSelf.height = 20 }} 根据inout类型的说明，我们知道，实际上这相当于增加了一个隐藏的临时变量，self被复制，然后在closure(闭包)中使用，完成后，再复制回self。也就是说，这个方法有额外的内存开销。如果是struct较大的情形，这么做并不划算。 方案二：使用UnsafeMutablePointer&lt;Pointee&gt; 这次采用直接指针的方式对于struct来进行操作，采用指针的好处是self不会被多次复制，性能较高。缺点是你需要自行确定你的代码的安全。 123456789101112struct RecordModel { /// 定义一个闭包 var action: (() -&gt; ())? var height = 10 let selfPointer = UnsafeMutablePointer(&amp;self) self.action = { selfPointer.pointee.height = 20 }} 结论Closure cannot implicitly capture a mutating self parameter错误的原因是在进出closure(闭包)之后，self的一致性没办法得到保证，所以编译器默认不允许在struct的closure(闭包)中使用self。如果我们确定这么做是安全的，就可以通过上面的两种方式解决这个问题。其中，方法二的性能更好一些。 注意 这里可以记一下指针和swift变量之间的关系： UnsafePointer对应let UnsafeMutablePointer对应var AutoreleasingUnsafeMutablePointer对应unowned UnsafeMutablePointer，用于inout的参数类型 UnsafeRawPointer对应let Any，raw系列都是对应相应的Any类型 UnsafeBufferPointer是non-owning的类型（unowned），用于collection的elements, buffer系列均如此 Declarations from extensions cannot be overridden yet 错误这个错误大致是因为,协议方法是在extension里面的,不能被重写 解决办法:(仅供参考,如有更好的建议还望多多指教) 小编想到的解决办法就是在每一个需要此协议的类里面,重新遵循代理,实现该协议方法 &quot;Method 'initialize()' defines Objective-C class method 'initialize', which is not permitted by Swift&quot;报错原因: 在于已经废弃的initialize方法,示例如下 方法交叉(Method Swizzling) 有时为了方便，也有可能是解决某些框架内的 bug，或者别无他法时，需要修改一个已经存在类的方法的行为。方法交叉可以让你交换两个方法的实现，相当于是用你写的方法来重载原有方法，并且还能够是原有方法的行为保持不变。 1234567extension UIViewController { public override class func initialize() {//此处报错 //此处省略100行代码 }} initialize该方法已经被Swift4.0废弃 在Swift3.0还勉强可以使用,但是会有警告;但是在4.0已经被完全废弃 替代方法: 在 app delegate 中实现方法交叉 像上面通过类扩展进行方法交叉，而是简单地在 app delegate 的 application(_:didFinishLaunchingWithOptions:) 方法调用时调用该方法 1234567891011121314extension UIViewController { public override class func initializeOnceMethod() { //此处省略100行代码 }}//在AppDelegate的方法中调用:func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil) -&gt; Bool { //此处省略100行代码 UIViewController.initializeOnceMethod()} 'dispatch_once' is unavailable in Swift: Use lazily initialized globals instead 报错原因: dispatch_once在Swift4.0也已经被废弃 123456789extension UITableView { struct once{ static var onceTaken:Int = 0 } dispatch_once(&amp;once.onceTaken) { () -&gt; Void in //在这里dispatch_once就会报错 //此处省略1000000行代码 }} 解决方法: 通过给DispatchQueue添加扩展实现 12345678910111213141516171819202122extension DispatchQueue { private static var _onceTracker = [String]() public class func once(token: String, block: () -&gt; ()) { objc_sync_enter(self) defer { objc_sync_exit(self) } if _onceTracker.contains(token) { return } _onceTracker.append(token) block() } func async(block: @escaping ()-&gt;()) { self.async(execute: block) } func after(time: DispatchTime, block: @escaping ()-&gt;()) { self.asyncAfter(deadline: time, execute: block) }} 使用字符串token作为once的ID，执行once的时候加了一个锁，避免多线程下的token判断不准确的问题。使用的时候可以传token 123DispatchQueue.once(token: \"tableViewOnce\") { print( \"Do This Once!\" ) } 或者使用UUID也可以： 12345private let _onceToken = NSUUID().uuidStringDispatchQueue.once(token: _onceToken) { print( \"Do This Once!\" ) } 后续又遇到别的问题会继续更新 文章中如有解释不足之处,还望多多指教","link":"/2017/08/25/升级Swift4.0遇到的坑/"},{"title":"发布开源框架到CocoaPods入坑指南","text":"在开发过程中一定会用到一些第三方框架, 只要安装了CocoaPods, 然后通过pod install命令, 就可以集成框架到项目中了 可是如果想要把自己的框架或者组件也开源出去, 让别人也可以使用, 那该如何入手 ? 对于CocoaPods还不是很了解的或者没有安装的童鞋, 可自行百度或者参考用CocoaPods做程序的依赖 搭建框架创建仓库 CocoaPods项目的源码在Github上管理,所以第一步我们需要创建一个属于自己的仓库 根据图下图所示创建自己的项目 上传文件 要开发框架必然就要上传文件, 这里推荐SourceTree和GitHub客户端, 当然也可以使用终端命令上传 使用git管理工具我们这里暂不赘述, 不懂得可以自行百度 终端使用git命令上传, 主要命令如下 12345678910111213141516171819//cd到当前文件夹// 创建本地仓库git init// 添加名称为origin的远程连接git remote add origin '你的github项目地址'// 将本地代码加入本地仓库里git add .// 提交修改到本地仓库git commit -m '你的修改记录'// 推送master分支的代码到名称为origin的远程仓库git push origin master//本地打标签备份git tag \"v0.0.1\"//提交标签git push --tags//删除本地标签git tag -d 标签名称//删除远程标签git push origin: 标签名称 使用CocoaPods检索第三方框架 使用命令pod search xxx 从本地缓存的–第三方框架描述信息–生成的检索文件中检索到响应的框架信息 本地缓存的框架描述信息位置: ~/Library/Caches/CocoaPods/search_index.json 如执行命令时出现错误, 可删除改索引文件, 执行命令: rm ~/Library/Caches/CocoaPods/search_index.json 安装第三方框架 创建Podfile文件, 到自己工程内(一级目录): pod init Podfile文件: 答: 其实就是使用ruby语法编写的 “框架依赖描述文件”; 就是告诉cocoapods需要下载集成哪些框架 安装框架 pod install cocoapods在1.0.1以后版本, 会直接就是根据Podfile文件找到, 框架信息, 然后下载集成 但是1.0.1之前的版本, 会先更新本地的框架描述信息(非常耗时), 然后再根据文件下载 下载完成后会生成一个Podfile.lock文件, 记录着上一次下载的框架最新版本 pod install和pod update pod install 如果Podfile.lock文件存在, 直接从此文件中读取框架信息下载安装 如果不存在, 依然会读取Podfile文件内的框架信息, 下载好之后, 再根据下载好的框架信息, 生成Podfile.lock文件 pod update 不管Podfile.lock是否存在, 都会读取Podfile文件的的框架信息去下载 下载好之后, 再根据下载好的框架信息, 生成Podfile.lock文件 主要区别在于, Podfile文件内的框架信息, 版本描述没有指定具体版本 一般情况下, 每个人从共享库把项目下载下来之后, 都会执行pod install命令安装!这样可以保证大家使用的第三方框架版本一致!!如果以后大家需要统一升级第三方框架, 那么每个人在执行 pod update CocoaPods相关操作1234567891011121314151617//创建Podfile文件pod init//搜索框架pod search//安装框架pod install//更新框架pod update//初始化(下载服务器中所有的第三方框架信息缓存到电脑本地)pod setup//查看第三方框架仓库源pod repo//移除仓库源pod repo remove master//添加仓库源//pod repo add master https://xxxx.... CocoaPods相关路径123456789//索引缓存路径//如果发现框架信息本地已经缓存, 但是就是无法搜索框架, 可以删除这个索引文件, 重新生成 ~/Library/Caches/CocoaPods/ //pod命令安装路径 /usr/local/bin //pod框架索引信息缓存路径 /Users/apple/.cocoapods/repos/master 创建Podspec描述文件 该文件为Cocoapods依赖库的描述文件，每个Cocoapods依赖库必须有且仅有那么一个描述文件 简单地讲就是让CocoaPods搜索引擎知道你的代码的作者、版本号、源代码地址、依赖库等信息的文件 文件名称要和我们想创建的依赖库名称保持一致 1234pod spec create 框架名字// 示例:pod spec create TitanModel 该命令将在本目录产生一个名为TitanModel.podspec文件 可用Sublime Text或者Atom打开该文件，里面已经有非常丰富的说明文档, 但是很多都是我们不需要的 官方Podspec文件的编写格式可参考 Podspec Syntax Reference 下面介绍如何声明第三方库的代码目录和资源目录，还有该第三方库所依赖ios核心框架和第三方库 去掉文件中的一些注释信息, 可以看到也就剩下以下内容了 1234567891011121314151617181920212223242526272829303132333435Pod::Spec.new do |s| s.name = 'TitanModel' #项目名 s.version = '0.1.0' #相应的版本号 s.summary = 'A short description of YJDemoSDK.' #简述 s.description = &lt;&lt;‐ DESC #详细描述 TODO: Add long description of the pod here. DESC s.homepage = 'https://github.com/CoderTitan/TitanModel' #项目主页 s.license = { :type =&gt; 'MIT', :file =&gt; 'LICENSE' } #开源协议 s.author = { 'CoderTitan' =&gt; 'quanjunt@163.com' } #作者 s.platform = :ios, '8.0' #支持的平台 s.requires_arc = true #arc和mrc选项 s.libraries = 'z', 'sqlite3' #表示依赖的系统类库，比如libz.dylib等 s.frameworks = 'UIKit','AVFoundation' #表示依赖系统的框架 s.ios.vendored_frameworks = 'TKBase/TKBase.framework' # 依赖的第三方/自己的framework s.vendored_libraries = 'Library/Classes/libWeChatSDK.a' #表示依赖第三方/自己的静态库（比如libWeChatSDK.a） #依赖的第三方的或者自己的静态库文件必须以lib为前缀进行命名，否则会出现找不到的情况，这一点非常重要 #平台信息 s.platform = :ios, '7.0' s.ios.deployment_target = '7.0' #文件配置项 s.source = { :git =&gt; 'https://github.com/CoderTitan/TitanModel.git', :tag =&gt; s.version.to_s } #配置项目的目标路径，如果不是本地开发，pod init/update会从这个路去拉去代码 s.source_files = 'TitanModel/Classes/**/*' #你的源码位置 s.resources = ['TitanModel/Assets/*'] #资源，比如图片，音频文件等 s.public_header_files = 'TitanModel/Classes/TitanModel.h' #需要对外开放的头文件 #依赖的项目内容 可以多个 s.dependency 'MJExtension' s.dependency 'AFNetworking'end s.name：名称，pod search搜索的关键词,注意这里一定要和.podspec的名称一样,否则报错 s.version：版本号，to_s：返回一个字符串 s.summary: 项目简短的简介 s.description: 这个是详细的描述, 要注意的是字数要比summary的长, 否则上传的时候可能会爆出警告 s.homepage: 项目主页地址 s.license: 许可证 s.author: 作者 s.source: 项目源码所在地址 s.platform: 项目支持平台 s.requires_arc: 是否支持ARC s.source_files: 需要包含的源文件 s.public_header_files: 需要包含的头文件 s.ios.deployment_target: 支持的pod最低版本 s.social_media_url: 社交网址 s.resources: 资源文件 s.dependency: 依赖库，不能依赖未发布的库 source_files写法及含义 12\"TitanModel\"\"Classes/**/*.{h,m}\" *表示匹配所有文件 *.{h,m}表示匹配所有以.h和.m结尾的文件 **表示匹配所有子目录 将自己的项目打成tag 因为cocoapods是依赖tag版本的,所以必须打tag,以后再次更新只需要把你的项目打一个tag，然后修改.podspec文件中的版本接着提交到cocoapods官方就可以了 要注意的是, 这里提交的版本号要和TitanModel.podspec文件中的版本号一致 12git tag &quot;v0.0.1&quot; git push --tags 上传Podspec Podspec修改完成后, 上传到服务器时, 我们需要使用trunk进行上传 首先要注册trunk, 在注册trunk之前，我们需要确认当前的CocoaPods版本是否足够新。trunk需要pod在0.33及以上版本，如果你不满足要求, 需要重新安装pod 更新结束后，我们开始注册trunk, 可参考官方文档Getting setup with Trunk 终端输入以下命令 1234pod trunk register 邮箱地址 &apos;用户名&apos; --description=&apos;描述&apos;// 示例pod trunk register quanjunt@163.com &apos;CoderTitan&apos; --description=&apos;macbook&apos; 执行该命令后, 你的邮箱会受到一封邮件, 但是邮件要到垃圾邮件中才能找到, 打开邮件找到邮件中的网址并打开 如果打开邮件中的链接和下面的页面一样, 则表示注册成功 最后输入如下命令 1pod trunk push TitanModel.podspec 时间较长，耐性等待，大概5-10分钟, 成功后结果如下 上面图片中可以看到执行了Updating spec repo master命令, 该命令主要就是更新本地的Specs文件 查看文件夹位置, 打开访达文件夹, Shift+command+G快捷键, 打开前往文件夹操作, 输入如下目录即可查看 1~/.cocoapods/repos/master/Specs 测试自己的cocoapods 终端输入pod search TitanModel查看 但是如果输入上述命令后, 终端输出如下错误 1[!] Unable to find a pod with name, author, summary, or description matching `TitanModel` 这是因为你的框架已经上传, 但是你的本地的搜索文件search_index.json没有更新, 所以搜索不到, 可以执行下面命令删除search_index.json文件 1rm ~/Library/Caches/CocoaPods/search_index.json 也可以直接找到该文件删除 查看文件夹位置, 打开访达文件夹, Shift+command+G快捷键, 打开前往文件夹操作, 输入如下目录即可查看 1~/Library/Caches/CocoaPods/ 搜索成功 错误整理版本号 设置版本号的时候一般有两种方式, 一种是前面带v的, 如: v0.0.1;另 一种是前面不带v的, 如:0.0.1 因为v而导致的报错 123warning: Could not find remote branch 0.0.1 to clone.fatal: Remote branch 0.0.1 not found in upstream origin 为解决以上问题, 设置版本号的方式和spec文件内的版本号方式一定要一致 不带v方式:设置版本号时: 123// 这里设置时, 不要带vgit tag &apos;0.0.1&apos; git push --tags spec文件中1234//这里不要带vs.version = &quot;0.0.2&quot;s.source = { :git =&gt; &quot;https://github.com/CoderTitan/TitanModell.git&quot;, :tag =&gt; s.version }//这里的tag也可以设置成具体的版本号, 只要与上面一样就好 带v方式:设置版本号时: 123// 这里设置时, 要带vgit tag &apos;v0.0.1&apos; git push --tags spec文件中 1234//这里要带vs.version = &quot;v0.0.2&quot;s.source = { :git =&gt; &quot;https://github.com/CoderTitan/TitanModell.git&quot;, :tag =&gt; &quot;v#{s.version} }//这里的tag也可以设置成具体的版本号, 只要与上面一样就好 总结最后对上述涉及到的终端命令做一个简单的总结 终端命令 开源库发布之后，需要给项目打上tag 12git tag &quot;0.0.1&quot; git push --tags 进入到项目根目录下，创建podspec文件 1pod spec create TitanModel 编辑podspec文件中的相关信息，有两个比较重要的地方s.source和s.source_files, 修改完成后, 验证是否有误 1pod spec lint TitanModel.podspec 注册pod trunk 1pod trunk register orta@cocoapods.org &apos;Orta Therox&apos; --description=&apos;macbook air&apos; 发布到trunk 1pod trunk push TitanModel.podspec 搜索发布的框架 1pod search TitanModel","link":"/2018/06/29/发布开源框架到CocoaPods入坑指南/"},{"title":"基于GitHub和Hexo搭建个人博客","text":"本文是使用Mac电脑, 基于GitHub和Hexo搭建个人博客, 搞了两三天, 反复尝试了无数次, 踩了无数坑搭建起来的, 主要跟大家分享一点小经验, 希望对大家能有帮助! github博客简介github 是全球最大的社交编程及代码托管网站，GitHub可以托管各种git库，并提供一个web界面，但与其它像SourceForge或Google Code这样的服务不同，GitHub的独特卖点在于从另外一个项目进行分支的简易性。这里着重写如何使用Github的page功能搭建个人博客! 使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 准备工作 有一个github账号，没有的话去GitHub注册一个 安装了node.js、npm，并了解相关基础知识 安装了git 环境搭建安装Node.js 用来生成静态页面, 到Node.js官网，下载最新版本, 根据提示一路安装即可 Node.js默认会安装 npm 也可以使用Homebrew进行命令安装, 详情参考React Native中文网安装方法 安装Git 用来将本地Hexo内容提交到Github上。下载的Xcode自带Git，这里不再赘述。 如果没有Xcode可以参考Hexo官网上的安装方法 通用版的Git安装, 无法下载的童鞋，可以去网上搜索下载 安装Hexo当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令： 1sudo npm install -g hexo 此时, 会提示你输入管理员密码(电脑密码), 开始安装 本地搭建 hexo 静态博客 在电脑中新建一个文件夹, 文件夹名字随意, 如MyBlog 在终端, cd 进入该文件夹 终端运行 git, 生成hexo模板，可能要翻墙 1hexo init 安装完模板, 安装npm 1npm install 最后, 开启hexo服务器 1hexo s 此时，浏览器中打开网址http://localhost:4000，能看到如下页面： 将博客与Github关联在GitHub上配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 首先检查本机是否存在的ssh密钥 如果存在, 直接进行步骤1.3, 否则执行步骤1.2生成新的密钥 打开终端输入, 注意~/.ssh之间没有空格 1cd ~/.ssh 如果提示：No such file or directory 说明你是第一次使用git, 或者之前没有安装过SSh密钥 生成新的ssh key注意后面添加自己注册GitHub的邮箱地址, 打开终端输入 1ssh-keygen -t rsa -C \"邮件地址\" 输入命令后, 然后连续回车, 默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件 打开’访达’, 选择进入文件夹(快捷键Command+Shift+G), 输入~/.ssh, 进入该文件夹 将ssh key添加到Github中打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将刚复制的内容粘贴到key那里，title随便填，保存 测试SSH配置是否成功1ssh -T git@github.com 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： 1Hi XXXX! You've successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 更改GitHub用户名和邮箱12$ git config --global user.name XXXX// 你的github用户名，非昵称$ git config --global user.email \"xxx@qq.com\"// 填写你的github注册邮箱 关联Github新建XXX.github.io 的项目 在 Github 上创建名字为 XXX.github.io 的项目，XXX为必须和自己的 github 用户名一模一样 修改_config.yml文件配置 打开本地的 MyBlog 文件夹项目内的_config.yml 配置文件 将其中的 type 设置为git，repository 是你 github.io 仓库的 git 地址, 如下所示 此处切记, 每一个毛好的后面都要加一个空格, 垂直方向一定要对齐, 否则可能会报错 1234deploy: type: git repository: https://github.com/CoderTitan/CoderTitan.github.io.git branch: master 将配置文件上传GitHub 打开终端, cd到MyBlog文件夹下, 以下命令均在MyBlog文件夹下执行 在blog文件夹目录下执行生成静态页面命令： 1hexo generate 或者：hexo g 此时若出现如下报错： 12ERROR Local hexo not found in ~/blogERROR Try runing: 'npm install hexo --save' 则执行命令： 1npm install hexo --save 再执行配置命令： 1hexo deploy 或者：hexo d 报错一: 若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git： 1npm install hexo-deployer-git --save 报错二: 若执行命令hexo d报以下错误: 123ERROR Plugin load failed: hexo-server//或者类似的错误ERROR Plugin load failed: hexo-renderer-sass 则执行响应的命令: 123sudo npm install hexo-server//或者sudo npm install hexo-renderer-sass 解决玩错误之后, 最后在执行1hexo d 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； hexo d命令执行成功后，浏览器中打开网址http://XXX.github.io（将XXX换成你的用户名）能看到和打开http://localhost:4000时一样的页面 安装theme主题 搭建好的默认的主题真的是很丑, 所以这里我们先替换一个好看的主题, 大家更可以到官方主题去选择自己喜欢的主题样式 示例主题: Random 终端cd到 MyBlog 目录下执行如下命令： 1git clone https://github.com/stiekel/hexo-theme-random.git themes/random 修改_config.yml中的theme: landscape改为theme: random，然后重新执行hexo g来重新生成 终端cd到MyBlog目录下执行如下命令(每次部署文章的步骤)： 12345hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g //生成缓存和静态文件 hexo d //重新部署到服务器 域名绑定 现在使用的域名是Github提供的二级域名XXX.github.io，也可以绑定为自己的个性域名。 购买域名，可以到GoDaddy官网，现在 GoDaddy已经有中文版了，虽然国家显示是新加坡，但不影响使用, 还可使用支付宝支付 也可以到阿里万网购买, 我是在万网买的，可直接在其网站做域名解析 域名解析如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。登录万网，在你购买的域名后边点击：解析, 如下图 进入解析页面后点击添加解析, 向你的 DNS 配置中添加 3 条记录, 如下图注意CNAME记录添加的是username.github.io.(不要忘记后面的.), 可能最后一个点不显示(我的就不显示) 设置GitHub配置信息 打开你的XXX.github.io项目地址, 找到设置页面 滚动到下方找到GitHub Pages模块, 在Custom domain, 输入你购买的域名, 点击Save保存 创建CNAME文件 在/MyBlog/themes/landscape/source目录下新建文件名为：CNAME文件，注意没有后缀名！直接将自己的域名写入 CNAME一定要大写 12//在终端cd到该目录下, 然后输入命令, 即可创建该文件touch CNAME 完成上述步骤后, 终端cd到MyBlog目录下执行如下命令重新部署： 最后, 等十分钟左右，刷新浏览器，用你自己域名访问下试试 12345$ hexo clean$ hexo g$ hexo d 至此也算终于大功告成了, 感受一下: https://www.titanjun.top","link":"/2018/03/08/基于GitHub和Hexo搭建个人博客/"},{"title":"Mac环境下MySQL命令的使用","text":"MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL所使用的SQL语言是用于访问数据库的最常用标准化语言。 由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，许多中小型网站为了降低网站总体拥有成本而选择了MySQL作为网站数据库。 MySQL是一个多用户、多线程的关系型数据库管理系统。 工作模式是基于客户机/服务器结构。目前它可以支持几乎所有的操作系统 简单的来说，MySQL是一个开放的、快速的、多线程的、多用户的SQL数据库服务器 MySQL的安装工欲善其事必先利其器, 要研究MySQL我们首先要安装MySQL, 这里只介绍Mac环境下的安装和数据库操作 下载MySQL直接打开MySQL官网下载页, 选择mac OS系统后, 选择DMG格式下载软件 接着, 会跳转到如下页面, 你只需要选择不登录,直接下载即可(当然也可以选择注册并登录) 下载好后, 按照dmg里面的pkg文件一路安装即可, 但是需要注意的是 除了倒数第二步之外按照默认一路安装即可 倒数第二步会有一个设置管理员密码的过程, 设置好后, 一定要牢记该密码, 后期链接数据库会需要 最后打开系统偏好设置, 最后会有一个MySQL的图标 打开MySQL会看到默认是开启的(安装的时候按照默认设置安装的情况下) 到这里MySQL就已经基本安装完成了, 不需要再修改什么配置了 安装Navicat for MySQL Navicat for MySQL是一套专为MySQL设计的高性能数据库管理及开发工具 它可以用于任何版本3.21或以上的 MySQL数据库服务器 支持大部份MySQL最新版本的功能，包括触发器、存储过程、函数、事件、视图、管理用户等 正版下载地址, 不过正版只有14天的试用时间 安装后, 按照下图完善配置即可, 其中连接名随意, 密码即为安装MySQL环境的时候设置的密码 MySQL的基本命令基本命令 首先要打开终端(Windows中是cmd), 以下命令均是在终端运行 启动/停止服务只有在Windows系统中才需要运行, Mac环境下不需要 启动/停止服务1234567// 启动服务 格式：net start 服务名称 示例：net start titansql// 停止服务 格式：net stop 服务名称 示例：net stop titansql 连接数据123格式：mysql -u 用户名 -p示例：mysql -u root -p// 此处会提示你输入密码(安装时设置的) 远程连接 链接他人或其他服务器的数据库 格式：mysql -h ip地址 -u 用户名 -p 输入对方mysql密码 其他命令需要注意的是: 以下所有命令中如过结尾有分号(;)的一定不能省略, 否则不是一条完整的命令, 系统会提示你继续输入命令 12345678// 查看版本（连接后可以执行）select version();//显示当前时间（连接后可以执行）select now();//退出登录(断开连接)quit或exit 数据库操作1234567891011// 1、创建数据库 格式：create database 数据库名 charset=utf8; 示例：create database titansql charset=utf8;// 2、删除数据库 格式：drop database 数据库名; 示例：drop database titansql;// 3、切换数据库 格式：use 数据库名; 示例：use titansql;// 4、查看当前选择的数据库 select database(); 创建完成记得刷新Navicat for MySQL 表操作12345678910111213141516171819202122232425262728293031323334// 1、查看当前数据库中所有表 show tables; // 2、创建表 格式：create table 表名(列及类型); 说明： //id, name, age: 等为字段名 //auto_increment: 表示自增长 //primary key: 表示主键 //int, varchar(20): 等为数据类型, 20为可存储的字节数 //not null: 表示不为空 //default: 为设置默认值 示例：create table student(id int auto_increment primary key, name varchar(20) not null, age int not null, gender bit default 1, address varchar(20), isDelete bit default 0); // 3、删除表 格式：drop table 表名; 示例：drop table student; // 4、查看表结构 格式：desc 表名; 示例：desc student; // 5、查看建表语句 格式：show create table 表名; 示例：show create table student; // 6、重命名表名 格式：rename table 原表名 to 新表名; 示例：rename table car to newCar; // 7、修改表 格式：alter table 表名 add|change|drop 列名 类型; 示例：alter table newcar add isDelete bit default 0 数据操作12345678910111213141516171819202122231、增 a、全列插入 格式：insert into 表名 values(...); 说明：主键列是自动增长，但是在全列插入时需要占位，通常使用0，插入成功以后以实际数据为准 示例：insert into student values(0, \"tom\", 19, 1, \"北京\", 0); b、缺省插入 格式：insert into 表名(列1,列2,……) values(值1,值2,……); 示例：insert into student(name, age, address) values(\"titan\", 19, \"上海\"); c、同时插入多条数据 格式：insert into 表名 values(...),(...),…… 示例：insert into student values(0, \"jun\", 18, 0, \"北京\", 0), (0, \"poi\", 22, 1, \"海南\", 0), (0, \"coder\", 20, 0, \"石家庄\", 0);2、删 格式：delete from 表名 where 条件; 示例：delete from student where id=4; 注意：没有条件是全部删除，慎用3、改 格式：update 表名 set 列1=值1,列2=值2,…… where 条件; 示例：update student set age=16 where id=7; 注意：没有条件是全部列都修改，慎用4、查 说明：查询表中的全部数据 格式：select * from 表名; 示例：select * from student; 查询数据基本语法 格式：select * from 表名; 说明： from关键字后面是表名，表示数据来源于这张表 select后面写表中的列名，如果是*表示在结果集中显示表中的所有列 在select后面的列名部分，可以使用as为列名起别名，这个别名显示在结果集中 如果要查询多个列，之间使用逗号分隔 示例： 12345678//查询所有数据select * from student;//查询某列数据select name, age from student;//以别名显示搜索结果select name as a, age from student; 消除重复行 在select后面列前面使用distinct可以消除重复的行 示例： 12select gender from student;select distinct gender from student; 条件查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 1、语法 select * from 表名 where 条件 // 2、比较运算符 等于 = 大于 &gt; 小于 &lt; 大于等于 &gt;= 小于等于 &lt;= 不等于 !=或&lt;&gt; 需求：查询id值大于8的所有数据 示例：select * from student where id&gt;8; // 3、逻辑运算符 and 并且 or 或者 not 非 需求：查询id值大于7的女同学 示例：select * from student where id&gt;7 and gender=0; // 4、模糊查询(like) %: 表示任意多个任意字符 _: 表示一个任意字符 需求：查询姓习的同学 示例： select * from student where name like \"习%\"; select * from student where name like \"习_\"; // 5、范围查询 in 表示在一个非连续的范围内 between...and... 表示在一个连续的范围内 需求：查询编号为8、10、12的学生 示例：select * from student where id in (8,10,12); 需求：查询编号为6到8的学生 示例：select * from student where id between 6 and 8;// 6、空判断 注意：null与\"\"是不同的 判断空：is null 判断非空： is not null 需求：查询没有地址的同学 示例：select * from student where address is null; 需求：查询有地址的同学 示例：select * from student where address is not null;// 7、优先级 小括号，not 比较运算符，逻辑运算符 and比or优先级高，如果同时出现并希望先选or,需要结合()来使用 聚合操作 为了快速等到统计数据，提供了5个聚合函数 count(*): 表示计算总行数，括号中可以写*和列名 max(列): 表示求此列的最大值 min(列): 表示求此列的最小值 sum(列): 表示求此列的和 avg(列): 表示求此列的平均值 1234567891011121314//需求：查询学生总数select count(*) from student;//需求：查询女生的编号最大值select max(id) from student where gender=0;//需求：查询女生的编号最小值select min(id) from student where gender=0; //需求：查询所有学生的年龄和select sum(age) from student;//需求：查询所有学生的年龄平均值select avg(age) from student; 分组 按照字段分组，表示此字段相同的数据会被放到一个集合中。 分组后，只能查询出相同的数据列，对于有差异的数据列无法显示在结果集中 可以对分组后的数据进行统计，做聚合运算 语法： select 列1,列2,聚合…… from 表名 group by 列1,列2,列3,……; 需求：查询男女生总数 示例： 12select gender,count(*) from student group by gender;select name,gender,count(*) from student group by gender,age; 分组后的数据筛选： 123select 列1,列2,聚合…… from 表名 group by 列1,列2,列3,…… having 列1,……聚合……;示例：select gender,count(*) from student group by gender having gender; where与having的区别： where是对from后面指定的表进行筛选，属于对原始数据的筛选 having是对group by的结果进行筛选 排序 语法：select * from 表名 order by 列1 asc|desc，列2 asc|desc , ……; 说明： 将数据按照列1进行排序，如果某些列1的值相同，则按照列2进行排序 默认按照从小到大的顺序排序 asc: 升序 desc: 降序 123//需求：将没有被删除的数据按年龄排序select * from student where isDelete=0 order by age desc;select * from student where isDelete=0 order by age desc, id desc; 分页 语法：select * from 表名 limit start,count; 说明：start索引从0开始 示例： 123select * from student limit 0,3;select * from student limit 3,3;select * from student where gender=1 limit 0,3; 关联123456789101112131415161718192021222324// 建表语句： 1、create table class(id int auto_increment primary key, name varchar(20) not null, stuNum int not null); 2、create table students(id int auto_increment primary key, name varchar(20) not null, gender bit default 1, classid int not null, foreign key(classid) references class(id));// 查询所有数据 select * from students; /* 关联查询： 分类： 1、表A inner join 表B： 表A与表B匹配的行会出现在结果集中 2、表A left join 表B： 表A与表B匹配的行会出现在结果集中，外加表A中独有的数据，未对应的数据使用null填充 3、表A right join 表B： 表A与表B匹配的行会出现在结果集中，外加表B中独有的数据，未对应的数据使用null填充 */select students.name,class.name from class inner join students on class.id=students.classid;select students.name,class.name from class left join students on class.id=students.classid;select students.name,class.name from class right join students on class.id=students.classid; 至此, MySQL中一些常用的命令行也基本介绍完了 下面看一些MySQL和Python是如何进行交互的 MySQL和Python的交互 Python要对MySQL数据库进行操作, 需要引入pymysql模块 pymsql是Python中操作MySQL的模块, 并且pymysql支持python3.x版本 首先要先安装pymysql, 终端执行一下语句 1pip3 install pymysql 创建数据库连接123456789101112131415161718192021222324252627# 链接数据库# 参数1：mysql服务所在主机的IP(可以是IP地址, 本机链接可以是localhost)# 参数2：用户名# 参数3：密码# 参数4：要连接的数据库名db = pymysql.connect('localhost', 'root', 'titanjun', 'titansql')# 创建游标, 查询数据默认为元组类型cursor = db.cursor()# 创建sql语句sql = \"select version()\"# 执行sql语句cursor.execute(sql)# 获取返回的信息data = cursor.fetchone()print(data)# 关闭游标cursor.close()# 关闭数据库db.close() 创建表12345678910111213141516171819202122import pymysqldb = pymysql.connect('localhost', 'root', 'jun.0929', 'titansql')# 创建游标, 查询数据默认为元组类型cursor = db.cursor()# 建表# 在建表之前要检查表是否存在, 如果存在则删除cursor.execute(\"drop table if exists userinfo\")# 创建表try: sql = \"create table userinfo(id int auto_increment primary key, age int not null)\" cursor.execute(sql) print('创建成功')except: print('创建表失败')cursor.close()db.close() 在表中插入数据1234567891011121314151617181920212223242526import pymysqldb = pymysql.connect('localhost', 'root', 'jun.0929', 'titansql')cursor = db.cursor()# 插入数据的字符串命令sql = 'insert into userinfo values'for i in range(10, 20): ageStr = \"(0, %d)\" % i addsql = sql + ageStr try: cursor.execute(addsql) # 提交到数据库, 不然无法保存新建或者修改的数据 db.commit() print('插入数据成功') except: # 如果提交失败则回滚到上一次的提交, 否则下一次提交可能会冲突 db.rollback() print('插入数据失败')cursor.close()db.close() 修改/更新/删除数据1234567891011121314151617181920import pymysqldb = pymysql.connect('localhost', 'root', 'jun.0929', 'titansql')cursor = db.cursor()# 修改/更新数据命令字符串sql = 'update userinfo set age=30 where id=4'# 删除数据命令字符串# sql = 'delete from userinfo where age=16'try: cursor.execute(sql) db.commit() print('数据更新成功')except: db.rollback() print('数据更新失败')cursor.close()db.close() 查询数据 fetchone: 获取下一个查询结果集，结果集是一个对象 fetchall: 接收全部的返回的行 rowcount: 是一个只读属性，返回execute()方法影响的行数 1234567891011121314151617181920212223242526import pymysqldb = pymysql.connect('localhost', 'root', 'jun.0929', 'titansql')cursor = db.cursor()# 查询数据字符串sql = 'select * from userinfo where age&gt;16'try: cursor.execute(sql) # 获得一条查询数据 print(cursor.fetchone()) print('查询到-%d-条数据' % cursor.rowcount) result = cursor.fetchall() for row in result: print('%d--%d' % (row[0], row[1])) print('数据查询成功')except: print('数据查询失败')cursor.close()db.close() 至此, Python和MySQL交互的最基本最简单的使用也介绍完了, 如有不足之处还望告知","link":"/2017/05/16/Mac数据库安装与使用MySQL/"},{"title":"Realm在iOS中的简单使用","text":"Realm是由美国YCombinator孵化的创业团队历时几年打造，第一个专门针对移动平台设计的数据库 Realm是一个跨平台的移动数据库引擎，目前支持iOS、Android平台，同时支持Objective-C、Swift、Java、React Native、Xamarin等多种编程语言 Realm并不是对SQLite或者CoreData的简单封装, 是由核心数据引擎C++打造，是拥有独立的数据库存储引擎，可以方便、高效的完成数据库的各种操作 Realm简单介绍Realm的优势与亮点 开源。Realm移动端数据库相关代码已全部开源。数千开发者在GitHub上参与了相关工作。另外还有几百个Realm数据库相关的扩展。 简单易用：Core Data、SQLite庞大的学习量和繁杂的代码足以吓退绝大多数刚入门的开发者，而换用Realm，则可以极大地减少学习代价和学习时间，让应用及早用上数据存储功能 跨平台：现在绝大多数的应用开发并不仅仅只在iOS平台上进行开发，还要兼顾到Android平台的开发。为两个平台设计不同的数据库是不明智的，而使用Realm数据库，iOS和Android无需考虑内部数据的架构，调用Realm提供的API就可以完成数据的交换 线程安全。程序员无需对在不同线程中，对数据库的读取一致性做任何考虑，Realm会保证每次读取都得到一致的数据 可视化工具Realm Browser为了配合Realm的使用，Realm还提供了一个轻量级的数据库查看工具Realm Browser，借助这个工具，开发者可以查看数据库当中的内容，并执行简单的插入和删除操作。Realm Browser可以在App Store中下载安装 需要注意的是 如果需要调试, 可以通过NSHomeDirectory()打印出Realm数据库地址, 找到对应的Realm文件, 然后用Realm Browser可视化工具打开即可 Realm的安装Realm的Github地址 手动安装当使用手工方式安装Realm时，可以按照如下步骤进行 登录Realm官方网站或者Github，下载Realm的最新版本并解压 将Realm.framework从ios/static/文件夹拖曳到您Xcode项目中的文件导航器当中, 确保Copy items if needed选中然后单击Finish 在Xcode文件导航器中选择您的项目，然后选择您的应用目标，进入到Build Phases选项卡中。在Link Binary with Libraries中单击 + 号然后添加libc++.tbd以及libz.tbd 使用CocoaPods安装当使用CocoaPods方式安装Realm时，以Objective-C为例 CocoaPods版本要求是1.1.0及以上版本 在Podfile中，添加pod 'Realm'，如有需要, 添加pod 'Realm/Headers'到测试项目中 在终端运行pod install即可安装 在Swift中需要输入pod 'RealmSwift'才可以安装 如果是混编项目，就需要安装OC的Realm, 然后要把 Swift/RLMSupport.swift文件一同编译进去 RLMSupport.swift RLMSupport.swift这个文件为Objective-C版本的Realm集合类型中引入了Sequence一致性，并且重新暴露了一些不能够从Swift中进行原生访问的Objective-C方法，例如可变参数variadic arguments等, 更加详细的说明见官方文档 Xcode插件 Realm提供了一个Xcode插件，来方便的创建RLMObject类，这需要我们首先安装相关的插件 打开Realm文件夹中的plugin/RealmPlugin.xcodeproj并进行编译，重启Xcode之后插件即可生效 当需要新建RLMObject类时，在新建类的选项中选择Realm Model Object即可 Realm的类定义说明在Realm框架中，定义了二十个核心类、常量、枚举类型、协议等，常用的如：RLMRealm类、RLMObject类、RLMResults类等, 我们可以从Realm的官方网站上查看所有的定义以及使用说明 RLMRealm类 一个RLMRealm类的对象可以认为是一个Realm的数据库。Realm数据库既可以存储在硬盘上，同时也可以存储在内存中 Realm是框架的核心所在，是我们构建数据库的访问点，就如同Core Data的管理对象上下文managed object context一样 RLMRealm类中，常用的属性或方法如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 获取默认的Realm数据库+ (instancetype)defaultRealm;//实例化一个RLMRealm类的对象//根据配置参数获得RLMRealm+ (nullable instancetype)realmWithConfiguration:(RLMRealmConfiguration *)configuration error:(NSError **)error;//根据指定持久化文件路径获得RLMRealm+ (instancetype)realmWithPath:(NSString *)path;//对Realm数据库进行读写操作//在Realm上开始写入事务, 每个Realm文件一次只能打开一个写事务- (void)beginWriteTransaction;//在当前写入事务中提交所有写入操作，并结束事务- (void)commitWriteTransaction;//没有足够的磁盘空间来保存写入或由于意外的I / O错误，此方法可能会失败, 并返回error信息- (BOOL)commitWriteTransaction:(NSError **)error;// 在当前写入事务中提交所有写入操作，而不收到此写入事件的特定通知- (BOOL)commitWriteTransactionWithoutNotifying:(NSArray&lt;RLMNotificationToken *&gt; *)tokens error:(NSError **)error;// 回滚在当前写入事务期间进行的所有写入并结束事务- (void)cancelWriteTransaction;//执行写入事务内给定块中包含的操作- (void)transactionWithBlock:(__attribute__((noescape)) void(^)(void))block;//执行写入事务内给定块中包含的操作, 如果发生错误，则返回时包含NSError描述问题的对象- (BOOL)transactionWithBlock:(__attribute__((noescape)) void(^)(void))block error:(NSError **)error;//添加或更新一个对象- (void)addObject:(RLMObject *)object;//将现有对象添加或更新到Realm中, 有则更新没有则插入- (void)addOrUpdateObject:(RLMObject *)object;//添加或更新多个对象- (void)addObjects:(id&lt;NSFastEnumeration&gt;)objects;- (void)addOrUpdateObjects:(id&lt;NSFastEnumeration&gt;)objects;//删除对象- (void)deleteObject:(RLMObject *)object;- (void)deleteObjects:(id)array;- (void)deleteAllObjects; RLMObject类 在Realm数据库中存储的都是RMObject对象，RLMObject类是所有可以存储在Realm数据库中的对象的根类 凡是可以存储在Realm数据库中的对象都是RLMObject类或RLMObject类的子类 要创建一个数据模型，我们只需要继承RLMObject，然后设计我们想要存储的属性即可 在RLMObject类中，我们可以添加属性，添加的属性类型可以支持如下类型： NSString：字符串 NSInteger, int, long, float, double：数字型，注意没有CGFloat BOOL/bool：布尔型 NSDate：日期型 NSData：二进制字符型 NSNumber&lt;X&gt;: 其中X必须RLMInt, RLMFloat, RLMDouble或 RLMBool类型 RLMArray&lt;X&gt;: 其中X必须是RLMObject类的子类, 用于建模多对多关系 RLMObject的子类，用于建模多对一关系 RLMObject类中，比较常用如下方法： 1234567891011121314151617//创建Realm对象, 传入一个NSArray或NSDictionary实例来设置对象属性的值- (nonnull instancetype)initWithValue:(nonnull id)value;//在Realm数据库中，获取该RLMObject类的所有对象+ (RLMResults *)allObjects;//根据查询条件返回满足条件的所有RLMObject类的对象+ (RLMResults *)objectsWhere:(NSString *)predicateFormat, ...;//使用默认Realm中的给定主键检索此对象类型的单个实例+ (nullable instancetype)objectForPrimaryKey:(nullable id)primaryKey;//从指定的Realm返回此对象类型的所有对象+ (nonnull RLMResults *)allObjectsInRealm:(nonnull RLMRealm *)realm;//返回与指定Realm中给定谓词匹配的此对象类型的所有对象+ (nonnull RLMResults *)objectsInRealm:(nonnull RLMRealm *)realm where:(nonnull NSString *)predicateFormat, ...; RLMResults类 当我们执行一个查询操作后，查询出满足条件的RLMObject对象会存放在一个RLMResults对象中 RLMResults类是一个数组类型的数据结构，因此在其类定义中，提供了很多与数组类似的属性和方法 相关属性 1234567891011//结果集合中的对象个数@property (readonly, assign, nonatomic) NSUInteger count;//结果集合中对象的类型@property (readonly, assign, nonatomic) RLMPropertyType type;//管理此结果集合的Realm对象@property (readonly, nonatomic) RLMRealm *_Nonnull realm;//结果集合中包含的对象的类名称@property (readonly, copy, nonatomic, nullable) NSString *objectClassName; 相关方法 1234567891011121314151617181920212223//返回结果集合中的第一个对象- (nullable RLMObjectType)firstObject;//返回结果集合中的最后一个对象- (nullable RLMObjectType)lastObject;//根据索引index获取其中的某个对象- (RLMObjectType)objectAtIndex:(NSUInteger)index;//根据对象返回其索引- (NSUInteger)indexOfObject:(RLMObjectArgument)object;//返回与谓词匹配的结果集合中第一个对象的索引- (NSUInteger)indexOfObjectWhere:(nonnull NSString *)predicateFormat, ...;//返回与结果集合中给定谓词匹配的所有对象- (RLMResults&lt;RLMObjectType&gt; *)objectsWhere:(NSString *)predicateFormat, ...;//返回RLMResults从现有结果集合中排序的内容- (RLMResults&lt;RLMObjectType&gt; *)sortedResultsUsingKeyPath:(NSString *)keyPath ascending:(BOOL)ascending;//返回RLMResults与现有结果集合不同的内容- (nonnull RLMResults&lt;RLMObjectType&gt; *)distinctResultsUsingKeyPaths:(nonnull NSArray&lt;NSString *&gt; *)keyPaths; 更多相关类及其属性和方法, 可参考官方文档 https://realm.io/docs/objc/latest/api/Classes.html Realm的使用Realm中一些常用的类及其类的属性和方法上面已经介绍了, 下面我们就介绍Realm的使用方法 创建RLMObject类我们首先创建一个Student类，该类是RLMObject类的一个子类, 下图就是按照之前安装的Xcode插件创建的 在Student添加两个属性, RLMObject官方建议在RLMObject类中添加的属性，是不需要指定属性关键字的，完全交由Realm处理 假如设置了，这些attributes会一直生效直到RLMObject被写入realm数据库 RLM_ARRAY_TYPE宏创建了一个协议，从而允许 RLMArray&lt;Car&gt;语法的使用 如果RLM_ARRAY_TYPE宏没有放置在模型接口的底部的话，您或许需要提前声明该模型类 1234567@interface Student : RLMObject@property int num;@property NSString *name;@endRLM_ARRAY_TYPE(Student) 存储操作 对于RLMObject类型的对象，我们可以直接对创建的对象进行存储 第一步, 初始化对象 12345678910// 方式一: 接受一个数组对象Student *stu1 = [[Student alloc]initWithValue:@[@1, @\"jun\"]];//方式二: 接受一个字典对象Student *stu2 = [[Student alloc]initWithValue:@{@\"num\": @2, @\"name\":@\"titan\"}];//方式三: 属性赋值Student *stu3 = [[Student alloc]init];stu3.num = 3;stu3.name = @\"titanjun\"; 第二步就是把RLMObject对象写入Realm数据库, 同样有三种方式 123456789101112131415161718192021222324//方式一: 提交事务处理//获取Realm对象RLMRealm *realm = [RLMRealm defaultRealm];//开始写入事务[realm beginWriteTransaction];//添加模型对象[realm addObject:stu1];//提交写入事务[realm commitWriteTransaction];//方式二: 在事务中调用addObject:方法RLMRealm *realm = [RLMRealm defaultRealm];[realm transactionWithBlock:^{ [realm addObject:webSite1]; [realm addObject:webSite2];}];//方式三: 在十五中创建新的对象并添加[realm transactionWithBlock:^{ //添加模型 [Student createInRealm:realm withValue:@{@\"num\": @3, @\"name\":@\"coder\"}];}]; 一定要注意的是 所有的必需属性都必须在对象添加到Realm前被赋值 如果在进程中存在多个写入操作的话，那么单个写入操作将会阻塞其余的写入操作，并且还会锁定该操作所在的当前线程 建议常规的最佳做法：将写入操作转移到一个独立的线程中执行 官方给出的建议：由于Realm采用了MVCC设计架构，读取操作并不会因为写入事务正在进行而受到影响 除非您需要立即使用多个线程来同时执行写入操作，不然您应当采用批量化的写入事务，而不是采用多次少量的写入事务 下面的代码就是把写事务放到子线程中去处理 1234567dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ RLMRealm *realm = [RLMRealm defaultRealm]; [realm transactionWithBlock:^{ [realm addObject: stu4]; }];}); 查询操作 Realm中也提供了功能强大的数据查询能力，如果会使用SQL语言的话，上手的难度更低 在Realm的查询功能中，也可以像SQL一样使用各种条件查询关键字，查询的结果会保存在一个RLMResults类的数组中 全量查询, 通过调用allObjects方法, 得到该表中的所有数据 条件查询，设置一些查询条件，从而查询出符合条件的对象 Realm的查询条件可以使用==、&lt;=、&lt;、&gt;=、&gt;、!=、BETWEEN、CONTAINS 以及 ENDSWITH等多种操作符 全量查询 12345678910111213//1. 获取所有数据RLMResults *resArr = [Student allObjects];NSLog(@\"%@\", resArr);//2. 添加一条数据RLMRealm *realm = [RLMRealm defaultRealm];Student *stu = [[Student alloc]initWithValue:@[@10, @\"coder\"]];[realm transactionWithBlock:^{ [realm addObject:stu];}];//3. 一旦检索执行之后, RLMResults 将随时保持更新NSLog(@\"%@\", resArr); 条件查询 123456789101112131415//条件查询RLMResults *stuArr = [Student objectsWhere:@\"num &gt; 7\"];NSLog(@\"%@\", stuArr);//排序//排序不会对原数组进行操作, 会返回一个新的数组RLMResults *stuArr2 = [stuArr sortedResultsUsingKeyPath:@\"name\" ascending:YES];NSLog(@\"%@\", stuArr2);//链式查询RLMResults *stuArr3 = [stuArr2 objectsWhere:@\"num &gt; 8\"];//可以不断的根据上一个查询结果进行查询RLMResults *stuArr4 = [stuArr3 objectsWhere:@\"num &gt; 9\"];NSLog(@\"%@\", stuArr4); 更新操作 需要修改的模型一定是被Realm所管理的模型, 而且已经和磁盘上的对象进行地址映射 对新添加的模型进行更新 1234567891011121314//获取Realm对象RLMRealm *realm = [RLMRealm defaultRealm];Student *stu4 = [[Student alloc]initWithValue:@{@\"num\": @4, @\"name\":@\"titan4\"}];//添加数据// 这个模型stu, 已经被realm 所管理, 而且, 已经和磁盘上的对象, 进行的地址映射[realm transactionWithBlock:^{ //添加模型 [realm addObject:stu4];}];// 这里修改的模型, 一定是被realm所管理的模型[realm transactionWithBlock:^{ stu4.name = @\"coder4\";}]; 根据查询到的数据更新指定属性的数据 12345678//条件查询RLMResults *results = [Student objectsWhere:@\"num = 4\"];Student *stu = results.firstObject;//更新指定属性的数据[realm transactionWithBlock:^{ stu.name = @\"titanking\";}]; 当有主键的情况下, 使用Update方法 addOrUpdateObject会去先查找有没有传入的Student相同的主键，如果有，就更新该条数据 这里需要注意，addOrUpdateObject这个方法不是增量更新，所有的值都必须有，如果有哪几个值是null，那么就会覆盖原来已经有的值，这样就会出现数据丢失的问题 createOrUpdateInRealm:withValue这个方法是增量更新的，后面传一个字典，使用这个方法的前提是有主键 方法会先去主键里面找有没有字典里面传入的主键的记录，如果有，就只更新字典里面的子集;如果没有，就新建一条记录 12345678910111213//获取Realm对象RLMRealm *realm = [RLMRealm defaultRealm];Student *stu2 = [[Student alloc]initWithValue:@{@\"num\": @12, @\"name\":@\"titan\"}];//addOrUpdateObject方式[realm transactionWithBlock:^{ [realm addOrUpdateObject:stu2];}];//createOrUpdateInRealm方式[realm transactionWithBlock:^{ [Student createOrUpdateInRealm:realm withValue:@{@\"num\": @11, @\"name\":@\"titan11\"}];}]; 删除操作 删除的模型, 一定要求是被realm所管理的已经存在的模型 当需要在Realm中删除某些对象时，需要注意的是，该方法的执行需要在一个事务中进行 123456789101112131415161718192021222324252627282930313233343536373839//获取Realm对象RLMRealm *realm = [RLMRealm defaultRealm];//根据条件删除一条数据 RLMResults *results = [Student objectsWhere:@\"name = 'titanking'\"];Student *titan1 = results.firstObject;// 删除单条记录[realm transactionWithBlock:^{ [realm deleteObject:titan1];}];//删除所有符合条件的数据RLMResults *results = [Student objectsWhere:@\"name = 'coder'\"];for (Student *stu in results) { [realm transactionWithBlock:^{ [realm deleteObject:stu]; }];}//删除表中所有的数据[realm transactionWithBlock:^{ [realm deleteAllObjects];}];/*场景, 根据主键删除一个模型*/ // 1. 根据主键, 查询到这个模型(这个模型, 就是被realm数据库管理的模型)Student *res = [Student objectInRealm:realm forPrimaryKey:@4];//2. 删除该模型[realm transactionWithBlock:^{ [realm deleteObject:res];}]; Realm数据库机制 上面用到的获取realm对象的方式都是通过defaultRealm来获取默认配置的realm对象 当我们需要创建不同的realm表格时又该如何操作呢? 下面我们来看一下 1234567891011121314- (void)setDefaultRealmForUser:(NSString *)username { //先获取默认配置 RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration]; //设置只读数据库 //config.readOnly = YES; // 使用默认的目录，但是使用用户名来替换默认的文件名 config.fileURL = [[[config.fileURL URLByDeletingLastPathComponent] URLByAppendingPathComponent:username] URLByAppendingPathExtension:@\"realm\"]; // 将这个配置应用到默认的 Realm 数据库当中 [RLMRealmConfiguration setDefaultConfiguration:config];} 做好上述配置之后, 便可创建不同的数据库了 12345// 不同的用户, 使用不同的数据库[self setDefaultRealmForUser:@\"zhangsan\"];//这里也只需要调用默认配置即可RLMRealm *realm = [RLMRealm defaultRealm]; 通知 Realm实例将会在每次写入事务提交后，给其他线程上的Realm实例发送通知 一般控制器如果想一直持有这个通知，就需要申请一个属性, 强引用该属性，strong持有这个通知 集合通知是异步触发的，首先它会在初始结果出现的时候触发，随后当某个写入事务改变了集合中的所有或者某个对象的时候，通知都会再次触发 123456789101112131415161718192021222324252627//强引用属性@property (nonatomic, strong) RLMNotificationToken *token;- (void)setUp { [super setUp]; RLMRealm *realm = [RLMRealm defaultRealm]; // 获取 Realm 通知 self.token = [realm addNotificationBlock:^(RLMNotification _Nonnull notification, RLMRealm * _Nonnull realm) { NSLog(@\"接收到变更通知--%@\", notification); }]; //结束该通知 [self.token stop];}- (void)testExample { NoticeModel *noticeM = [[NoticeModel alloc] initWithValue:@{@\"num\": @1, @\"name\": @\"sz\"}]; //添加数据, 数据操作之后便会通知上述通知中心执行相应操作 RLMRealm *realm = [RLMRealm defaultRealm]; [realm transactionWithBlock:^{ [realm addObject:noticeM]; }];} 数据库迁移 数据库存储方面的增删改查应该都没有什么大问题，比较蛋疼的应该就是数据迁移了 在版本迭代过程中，很可能会发生表的新增，删除，或者表结构的变化，如果新版本中不做数据迁移，用户升级到新版，很可能就直接crash了 数据迁移一直是困扰各类型数据库的一大问题, 但是对于Realm来说, 却方便很多, 这也是Realm的优点之一 新增删除表，Realm不需要做迁移 新增删除字段，Realm不需要做迁移; Realm会自行检测新增和需要移除的属性，然后自动更新硬盘上的数据库架构 123456789101112131415161718192021222324252627282930313233343536373839404142//需要在以下方法中进行配置- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // 获取默认配置, 迁移数据结构 RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration]; // 1. 设置新的架构版本。这个版本号必须高于之前所用的版本号（如果您之前从未设置过架构版本，那么这个版本号设置为 0） int newVersion = 4; config.schemaVersion = newVersion; // 2. 设置闭包，这个闭包将会在打开低于上面所设置版本号的 Realm 数据库的时候被自动调用 [config setMigrationBlock:^(RLMMigration *migration, uint64_t oldSchemaVersion){ if (oldSchemaVersion &lt; newVersion) { NSLog(@\"数据结构会自动迁移\"); // enumerateObjects:block: 遍历了存储在 Realm 文件中的每一个“Person”对象 [migration enumerateObjects:@\"DataMigration\" block:^(RLMObject * _Nullable oldObject, RLMObject * _Nullable newObject) { // 只有当 Realm 数据库的架构版本为 0 的时候，才添加 “fullName” 属性 if (oldSchemaVersion &lt; 1) { newObject[@\"fullName\"] = [NSString stringWithFormat:@\"%@ %@\", oldObject[@\"firstName\"], oldObject[@\"lastName\"]]; } // 只有当 Realm 数据库的架构版本为 0 或者 1 的时候，才添加“email”属性 if (oldSchemaVersion &lt; 2) { newObject[@\"email\"] = @\"\"; } // 替换属性名(原字段重命名) if (oldSchemaVersion &lt; 3) { // 重命名操作应该在调用 `enumerateObjects:` 之外完成 [migration renamePropertyForClass:Person.className oldName:@\"yearsSinceBirth\" newName:@\"age\"]; } }]; } }]; // 3. 告诉 Realm 为默认的 Realm 数据库使用这个新的配置对象 [RLMRealmConfiguration setDefaultConfiguration:config]; // 4. 现在我们已经告诉了 Realm 如何处理架构的变化，打开文件之后将会自动执行迁移 [RLMRealm defaultRealm]; return YES;} 以上就是我最近学习到的关于Realm的部分内容, 文章不全, 有兴趣的可以参考下面的文章继续学习 参考文档 Realm数据库 从入门到“放弃” Realm官方文档 Realm GitHub","link":"/2018/08/10/Realm在iOS中的简单使用/"},{"title":"Socket搭建即时通讯服务器","text":"即时通讯 相关代码Demo地址 即时通讯（Instant messaging，简称IM）是一个终端服务，允许两人或多人使用网路即时的传递文字讯息、档案、语音与视频交流 即时通讯按使用用途分为企业即时通讯和网站即时通讯 根据装载的对象又可分为手机即时通讯和PC即时通讯，手机即时通讯代表是短信，网站、视频即时通讯 IM通信原理 客户端A与客户端B如何产生通信？客户端A不能直接和客户端B，因为两者相距太远。 这时就需要通过IM服务器，让两者产生通信. 客户端A通过socket与IM服务器产生连接,客户端B也通过socket与IM服务器产生连接 A先把信息发送给IM应用服务器，并且指定发送给B，服务器根据A信息中描述的接收者将它转发给B，同样B到A也是这样。 通讯问题: 服务器是不能主动连接客户端的，只能客户端主动连接服务器 即时通讯连接原理 即时通讯都是长连接，基本上都是HTTP1.1协议，设置Connection为keep-alive即可实现长连接，而HTTP1.1默认是长连接，也就是默认Connection的值就是keep-alive HTTP分为长连接和短连接，其实本质上是TCP连接，HTTP协议是应用层的协议，而TCP才是真正的传输层协议, IP是网络层协议，只有负责传输的这一层才需要建立连接 例如: 急送一个快递，HTTP协议指的那个快递单，你寄件的时候填的单子就像是发了一个HTTP请求。而TCP协议就是中间运货的运输工具，它是负责运输的，而运输工具所行驶的路就是所谓的TCP连接 HTTP短连接（非持久连接）是指，客户端和服务端进行一次HTTP请求/响应之后，就关闭连接。所以，下一次的HTTP请求/响应操作就需要重新建立连接。 HTTP长连接（持久连接）是指，客户端和服务端建立一次连接之后，可以在这条连接上进行多次请求/响应操作。持久连接可以设置过期时间，也可以不设置 即时通讯数据传递方式目前实现即时通讯的有四种方式（短轮询、长轮询、SSE、Websocket） 短轮询: 每隔一小段时间就发送一个请求到服务器，服务器返回最新数据，然后客户端根据获得的数据来更新界面，这样就间接实现了即时通信 优点是简单，缺点是对服务器压力较大，浪费带宽流量（通常情况下数据都是没有发生改变的）。 主要是客户端人员写代码，服务器人员比较简单，适于小型应用 长轮询: 客户端发送一个请求到服务器，服务器查看客户端请求的数据(服务器中数据)是否发生了变化（是否有最新数据），如果发生变化则立即响应返回，否则保持这个连接并定期检查最新数据，直到发生了数据更新或连接超时 同时客户端连接一旦断开，则再次发出请求，这样在相同时间内大大减少了客户端请求服务器的次数. 弊端:服务器长时间连接会消耗资源，返回数据顺序无保证，难于管理维护 底层实现:在服务器的程序中加入一个死循环，在循环中监测数据的变动。当发现新数据时，立即将其输出给浏览器并断开连接，浏览器在收到数据后，再次发起请求以进入下一个周期 SSE （Server-sent Events服务器推送事件）:为了解决浏览器只能够单向传输数据到服务端，HTML5提供了一种新的技术叫做服务器推送事件SSE SSE技术提供的是从服务器单向推送数据给浏览器的功能，加上配合浏览器主动HTTP请求，两者结合起来,实际上就实现了客户端和服务器的双向通信. WebSocket 以上提到的这些解决方案中，都是利用浏览器单向请求服务器或者服务器单向推送数据到浏览器 而在HTML5中，为了加强web的功能，提供了websocket技术，它不仅是一种web通信方式，也是一种应用层协议 它提供了浏览器和服务器之间原生的全双工跨域通信，通过浏览器和服务器之间建立websocket连接,在同一时刻能够实现客户端到服务器和服务器到客户端的数据发送 WebSocket WebSocket 是一种网络通信协议。RFC6455 定义了它的通信标准 WebSocket是一种双向通信协议，在建立连接后，WebSocket 服务器和客户端都能主动的向对方发送或接收数据 WebSocket是基于HTTP协议的，或者说借用了HTTP协议来完成一部分握手(连接)，在握手(连接)阶段与HTTP是相同的,只不过HTTP不能服务器给客户端推送，而WebSocket可以 WebSocket如何工作 Web浏览器和服务器都必须实现WebSockets协议来建立和维护连接。 由于WebSockets连接长期存在，与典型的HTTP连接不同，对服务器有重要的影响 基于多线程或多进程的服务器无法适用于 WebSockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接 任何实际的WebSockets服务器端实现都需要一个异步服务器 Websocket协议协议头: ws, 服务器根据协议头判断是Http还是websocket 1234567891011121314151617181920// 请求头 GET ws://localhost:12345/websocket/test.html HTTP/1.1 Origin: http://localhost Connection: Upgrade Host: localhost:12345 Sec-WebSocket-Key: JspZdPxs9MrWCt3j6h7KdQ== Upgrade: websocket Sec-WebSocket-Version: 13 // Sec-WebSocket-Key: 叫“梦幻字符串”是个密钥，只有有这个密钥 服务器才能通过解码认出来，这是个WB的请求，要建立TCP连接了！！！如果这个字符串没有按照加密规则加密，那服务端就认不出来，就会认为这整个协议就是个HTTP请求。更不会开TCP。其他的字段都可以随便设置，但是这个字段是最重要的字段，标识WB协议的一个字段 // 响应头 HTTP/1.1 101 Web Socket Protocol Handshake WebSocket-Location: ws://localhost:12345/websocket/test.php Connection: Upgrade Upgrade: websocket Sec-WebSocket-Accept: zUyzbJdkVJjhhu8KiAUCDmHtY/o= WebSocket-Origin: http://localhost // Sec-WebSocket-Accept: 叫“梦幻字符串”，和上面那个梦幻字符串作用一样。不同的是，这个字符串是要让客户端辨认的，客户端拿到后自动解码。并且辨认是不是一个WB请求。然后进行相应的操作。这个字段也是重中之重，不可随便修改的。加密规则，依然是有规则的 WebSocket客户端在客户端，没有必要为WebSockets使用JavaScript库。实现WebSockets的Web 浏览器将通过WebSockets对象公开所有必需的客户端功能（主要指支持HTML5的浏览器） 客户端 API以下 API 用于创建WebSocket对象。 1var Socket = new WebSocket(url, [protocol] ); 以上代码中的第一个参数url, 指定连接的URL 第二个参数protocol是可选的，指定了可接受的子协议 WebSocket属性以下是WebSocket对象的属性。假定我们使用了以上代码创建了Socket对象 Socket.readyState: 只读属性readyState表示连接状态, 可以是以下值 0 : 表示连接尚未建立 1 : 表示连接已建立，可以进行通信 2 : 表示连接正在进行关闭 3 : 表示连接已经关闭或者连接不能打开。 Socket.bufferedAmount: 只读属性bufferedAmount 表示已被send() 放入正在队列中等待传输，但是还没有发出的UTF-8文本字节数 WebSocket事件以下是WebSocket对象的相关事件。假定我们使用了以上代码创建了Socket 对象： 事件 事件处理程序 描述 open Socket.onopen 连接建立时触发 message Socket.onmessage 客户端接收服务端数据时触发 error Socket.onerror 通信发生错误时触发 close Socket.onclose 连接关闭时触发 WebSocket方法以下是WebSocket对象的相关方法。假定我们使用了以上代码创建了Socket对象： 方法 描述 Socket.send() 使用连接发送数据 Socket.close() 关闭连接 代码示例 12345678910111213141516171819202122// 客户端var socket = new WebSocket(\"ws://localhost:9090\")// 建立 web socket 连接成功触发事件socket.onopen = function () { // 使用send发送数据 socket.send(\"发送数据\") console.log(socket.bufferedAmount) alert('数据发送中')}// 接受服务端数据是触发事件socket.onmessage = function (evt) { var received_msg = evt.data alert('数据已经接受..')}// 断开 websocket 连接成功触发事件socket.onclose = function () { alert('链接已经关闭') console.log(socket.readyState)} WebSocket服务端WebSocket在服务端的实现非常丰富。Node.js、Java、C++、Python 等多种语言都有自己的解决方案, 其中Node.js常用的有以下三种 µWebSockets Socket.IO WebSocket-Node 下面就着重研究一下Socket.IO吧, 因为别的我也不会, 哈哈哈哈…… Socket.IO Socket.IO是一个库，可以在浏览器和服务器之间实现实时，双向和基于事件的通信 Socket.IO是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架 Socket.IO包括了客户端(iOS,Android)和服务器端(Node.js)的代码，可以很好的实现iOS即时通讯技术 Socket.IO支持及时、双向、基于事件的交流，可在不同平台、浏览器、设备上工作，可靠性和速度稳定 Socket.IO实际上是WebSocket的父集，Socket.io封装了WebSocket和轮询等方法，会根据情况选择方法来进行通讯 典型的应用场景如： 实时分析：将数据推送到客户端，客户端表现为实时计数器、图表、日志客户 实时通讯：聊天应用 二进制流传输：socket.io支持任何形式的二进制文件传输，例如图片、视频、音频等 文档合并：允许多个用户同时编辑一个文档，并能够看到每个用户做出的修改 Socket.IO服务端 Socket.IO实质是一个库, 所以在使用之前必须先导入Socket.IO库 Node.js导入库和iOS导入第三方库性质一样, 只不过iOS使用的是pods管理, Node.js使用npm 导入Socket.IO库123456789// 1. 进入当当前文件夹cd ...// 2. 创建package.json文件npm init/// 3. 导入库npm install socket.io --savanpm install express --sava 创建socket socket本质还是http协议，所以需要绑定http服务器，才能启动socket服务. 而且需要通过web服务器监听端口，socket不能监听端口，有人访问端口才能建立连接，所以先创建web服务器 123456789101112131415161718// 引入http模块var http = require('http')// 面向express框架开发，加载express框架，方便处理get,post请求var express = require('express')// 创建web服务器var server = http.Server(express)// 引入socket.io模块var socketio = require('socket.io')// 创建爱你socket服务器var serverSocket = socketio(server)server.listen(9090)console.log('监听9090') 建立socket连接 服务器不需要主动建立连接，建立连接是客户端的事情，服务器只需要监听连接 客户端主动连接会发送connection事件，服务端只需要监听connection事件有没有发送，就知道客户端有没有主动连接服务器 Socket.IO本质是通过发送和接受事件触发服务器和客户端之间的通讯，任何能被编辑成JSON或二进制的对象都可以传递 socket.on: 监听事件，这个方法会有两个参数，第一个参数是事件名称，第二个参数是监听事件的回调函数，监听到链接就会执行这个回调函数 监听connection，回调函数会传入一个连接好的socket，这个socket就是客户端的socket socket连接原理，就是客户端和服务端通过socket连接，服务器有socket，客户端也有 12345678// 监听客户端有没有连接成功,如果连接成功,服务端会发送connection事件,通知客户端连接成功// serverSocket: 服务端, clientSocket: 客户端serverSocket.on('connection', function (clientSocket) { // 建立socket连接成功 console.log('建立连接成功') console.log(clientSocket)}) Socket.IO客户端 Socket.IO-Client-Swift是iOS使用的库, 目前只有Swift版本 iOS中的使用 创建socket对象创建SocketIOClient对象, 两种创建方式 1234567// 第一种, SocketIOClientConfiguration: 可选参数public init(socketURL: URL, config: SocketIOClientConfiguration = [])// 第二种, 底层还是使用的第一种方式创建public convenience init(socketURL: URL, config: [String: Any]?) { self.init(socketURL: socketURL, config: config?.toSocketConfiguration() ?? [])} SocketIOClientConfiguration: 是一个数组, 等同于[SocketIOClientOption] SocketIOClientOption的所有取值如下 1234567891011121314151617181920212223242526272829303132333435363738public enum SocketIOClientOption : ClientOption { /// 使用压缩的方式进行传输 case compress /// 通过字典内容连接 case connectParams([String: Any]) /// NSHTTPCookies的数组, 在握手过程中传递, Default is nil. case cookies([HTTPCookie]) /// 添加自定义请求头初始化来请求, 默认为nil case extraHeaders([String: String]) /// 将为每个连接创建一个新的connect, 如果你在重新连接有bug时使用. case forceNew(Bool) /// 传输是否使用HTTP长轮询, 默认false case forcePolling(Bool) /// 是否使用 WebSockets. Default is `false` case forceWebsockets(Bool) /// 调度handle的运行队列, 默认在主队列 case handleQueue(DispatchQueue) /// 是否打印调试信息. Default is false case log(Bool) /// 可自定义SocketLogger调试日志 case logger(SocketLogger) /// 自定义服务器使用的路径. case path(String) /// 链接失败时, 是否重新链接, Default is `true` case reconnects(Bool) /// 重新连接多少次. Default is `-1` (无限次) case reconnectAttempts(Int) /// 等待重连时间. Default is `10` case reconnectWait(Int) /// 是否使用安全传输, Default is false case secure(Bool) /// 设置允许那些证书有效 case security(SSLSecurity) /// 自签名只能用于开发模式 case selfSigned(Bool) /// NSURLSessionDelegate 底层引擎设置. 如果你需要处理自签名证书. Default is nil. case sessionDelegate(URLSessionDelegate)} 创建SocketIOClient 12345// 注意协议：ws开头guard let url = URL(string: \"ws://localhost:9090\") else { return }let manager = SocketManager(socketURL: url, config: [.log(true), .compress])// SocketIOClientlet socket = manager.defaultSocket 监听连接 创建好socket对象,然后连接用connect方法 因为socket需要进行3次握手，不可能马上建议连接，需要监听是否连接成功的回调,使用on方法 ON方法两个参数 参数一: 监听的事件名称，参数二：监听事件回调函数，会自动调用 回调函数也有两个参数(参数一：服务器传递的数据 参数二:确认请求数据ACK) 在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据- ACK只是一个标记，标记是否成功传输数据 12345678910111213// 回调闭包public typealias NormalCallback = ([Any], SocketAckEmitter) -&gt; ()// on方法@discardableResultopen func on(_ event: String, callback: @escaping NormalCallback) -&gt; UUID// SocketClientEvent: 接受枚举类型的on方法@discardableResultopen func on(clientEvent event: SocketClientEvent, callback: @escaping NormalCallback) -&gt; UUID { // 这里调用的是上面的on方法 return on(event.rawValue, callback: callback)} 完整代码 12345678910111213guard let url = URL(string: \"ws://localhost:9090\") else { return }let manager = SocketManager(socketURL: url, config: [.log(true), .compress])let socket = manager.defaultSocket// 监听链接成功socket.on(clientEvent: .connect) { (data, ack) in print(\"链接成功\") print(data) print(ack)} socket.connect() SocketIO事件SocketIO通过事件链接服务器和传递数据 客户端监听事件123456// 监听链接成功socket.on(clientEvent: .connect) { (data, ack) in print(\"链接成功\") print(data) print(ack)} 客户端发送事件只有连接成功之后，才能发送事件 1234567891011// 建立一个连接到服务器. 连接成功会触发 \"connect\"事件open func connect()// 连接到服务器. 如果连接超时,会调用handleopen func connect(timeoutAfter: Double, withHandler handler: (() -&gt; ())?)// 重开一个断开连接的socketopen func disconnect()// 向服务器发送事件, 参数一: 事件的名称，参数二: 传输的数据组open func emit(_ event: String, with items: [Any]) 服务器监听事件 监听客户端事件，需要嵌套在连接好的connect回调函数中 必须使用回调函数的socket参数，如function(s)中的s，监听事件,因此这是客户端的socket，肯定监听客户端发来的事件 服务器监听连接的回调函数的参数可以添加多个，具体看客户端传递数据数组有几个，每个参数都是与客户段一一对应，第一个参数对应客户端数组第0个数据 123456789101112131415// 监听socket连接socket.on('connection',function(s){ console.log('监听到客户端连接'); // data:客户端数组第0个元素 // data1:客户端数组第1个元素 s.on('chat',function(data,data1){ console.log('监听到chat事件'); console.log(data,data1); });}); 服务器发送事件这里的socket一定要用服务器端的socket 12345678// 给当前客户端发送数据，其他客户端收不到.socket.emit('chat', '服务器' + data)// 发给所有客户端，不包含当前客户端socket.emit.broadcast.emit('chat', '发给所有客户端,不包含当前客户端' + data)// 发给所有客户端，包含当前客户端socket.emit.sockets.emit('chat', '发给所有客户端,包含当前客户端' + data) SocketIO分组 每一个客户端和服务器只会保持一个socket链接, 那么怎么吧每一条信息推送到对应的聊天室, 针对多个聊天室的问题有如何解决 给每个聊天室都分组, 服务器就可以给指定的组进行数据的推送, 就不会影响到其他的聊天室 如何分组 socket.io提供rooms和namespace的API 用rooms的API就可以实现多房间聊天了，总结出来无外乎就是：join/leave room 和 say to room 这里的socket是客户端的socket，也就是连接成功，传递过来的socket 123456789// join和leaveio.on('connection', function(socket){ socket.join('some room'); // socket.leave('some room');}); // say to roomio.to('some room').emit('some event'):io.in('some room').emit('some event'): 分组的原理 只要客户端socket调用join，服务器就会把客户端socket和分组的名称绑定起来 到时候就可以根据分组的名称找到对应客户端的socket，就能给指定的客户端推送信息 一个客户端socket只能添加到一组，离开的时候，要记得移除","link":"/2016/11/16/Socket搭建即时通讯服务器/"},{"title":"SwiftLint代码规范属性说明02","text":"这篇文章是继前两篇文章的继续更新 Xcode代码规范之SwiftLint配置–这篇文章对SwiftLint进行了简单介绍和针对Xcode的相关配置 SwiftLint代码规范属性说明01–这里介绍了上半部分的相关属性的介绍 下面来具体介绍一下SwiftLint的其他的代码规则的相关说明 规则51: legacy_cggeometry_functions当获取某个视图的宽、高、最小X、最大X值等等， swiftlint推荐使用swift的标准语法， 尽量不要使用从Objective-C中的遗留版本， 尽量语法swift化 识别码 默认是否启用 是否支持自动更正 类型 legacy_cggeometry_functions 启用 yes idiomatic 代码示例: 123456789/// 这样不推荐使用CGRectGetWidth(someView.frame)/// 推荐使用下面的形式rect.widthrect.heightrect.minXrect.midXrect................... 规则52: legacy_constant和属性legacy_cggeometry_functions一样， 结构范围常数尽量分开、明确、具体， 不要使用OC的遗留整体常数 识别码 默认是否启用 是否支持自动更正 类型 legacy_constant 启用 yes idiomatic 代码示例: 123456/// 规范的写法，不会触发warningCGPoint.zero/// 不规范的写法， 会触发warningCGPointZeroCGRectZero 规则53: legacy_constructorswiftlint要求系统自带构造器， 使用swift语法化， 不要使用OC版本的构造器 识别码 默认是否启用 是否支持自动更正 类型 legacy_constructor 启用 yes idiomatic 代码示例: 12345/// swift语法，相信之后系统也会强制规定使用CGPoint（x: 10， y: 20）/// 错误的构造器语法CGPointMake(10, 20) 规则54: legacy_nsgeometry_functionsns类几何函数， 和前面的几个属性一样， 使用swift点语法函数， 不使用以前的版本。 识别码 默认是否启用 是否支持自动更正 类型 legacy_nsgeometry_functions 启用 yes idiomatic 代码示例: 12345/// 正确view.width/height/minX/// 错误NSWidth(view.frame) 规则55: let_var_whitespacelet和var语句应该用空白行与其他语句分开 识别码 默认是否启用 是否支持自动更正 类型 let_var_whitespace 未启用 no style 代码示例: 12345678910//推荐这样写let a = 0var x = 1x = 2//不建议写法var x = 1x = 2 规则56: line_length行的字符长度属性。这个强烈不推荐使用。官方的规定是超过120字符就给warning， 超过200个字符就直接报error！！！我们又不是写底层脚本的，所以建议这种方式禁用！！ 识别码 默认是否启用 是否支持自动更正 类型 line_length 启用 no metrics 规则57: literal_expression_end_indentation字典和数组的开头和结尾要有相同的缩进格式 识别码 默认是否启用 是否支持自动更正 类型 literal_expression_end_indentation 未启用 no style 规则58: mark标记方法或者属性。这个推荐使用， 可以统一方法标记的格式， 有利于review查找某个方法或者属性的时候更清晰。使用也非常简单： “MARK”前空一格，”MARK:”后空一格。 识别码 默认是否启用 是否支持自动更正 类型 mark 启用 yes lint 代码示例: 123456789101112//推荐写法// MARK: good// MARK: - good// MARK: -//不建议写法//MARK: bad// MARK:bad//MARK:bad// MARK: bad// MARK: bad// MARK: -bad 规则59: multiline_arguments调用函数和方法时, 其参数应该在同一行上，或者每行一个 识别码 默认是否启用 是否支持自动更正 类型 multiline_arguments 未启用 no style 代码示例: 12345678//不建议以下写法foo(0, param1: 1, param2: true, param3: [3]) foo( 0, param1: 1, param2: true, param3: [3]) 规则60: multiline_parameters声明函数和方法时, 其参数应该在同一行上，或者每行一个 识别码 默认是否启用 是否支持自动更正 类型 multiline_parameters 未启用 no style 代码示例: 12345678910//不建议以下写法protocol Foo { func foo(param1: Int, param2: Bool, param3: [String]) { }}protocol Foo { func foo(param1: Int, param2: Bool, param3: [String]) { }} 规则61: multiple_closures_with_trailing_closure当函数有多个闭包时, 不建议使用尾随闭包语法 识别码 默认是否启用 是否支持自动更正 类型 multiple_closures_with_trailing_closure 启用 no style 代码示例: 12345678//不建议写法foo.something(param1: { $0 }) { $0 + 1 }UIView.animate(withDuration: 1.0, animations: { someView.alpha = 0.0}) { _ in someView.removeFromSuperview()} 规则62: nesting嵌套。类型嵌套至多一级结构， 函数语句嵌套至多五级结构。 识别码 默认是否启用 是否支持自动更正 类型 nesting 启用 no metrics 规则63: nimble_operator快捷操作符。和自由匹配函数相比， 更喜欢快捷操作符， 比如：&gt;=、 ==、 &lt;=、 &lt;等等。 识别码 默认是否启用 是否支持自动更正 类型 nimble_operator 未启用 yes idiomatic 代码示例: 123456789/// 会触发warning(person.voice).toNot(equal(\"Hello world\")) // 判断字符串相同10.to(beGreaterThan(5)) // 10比5大99.to(beLessThan(100)) // 99比100小// 改为以下(person.voice) != \"Hello world\" // 判断字符串相同10 &gt; 5 // 10比5大99 &lt; 100 // 99比100小 规则64: no_extension_access_modifier在extension扩展前面,不建议使用(fileprivate, public)等修饰符 识别码 默认是否启用 是否支持自动更正 类型 no_extension_access_modifier 未启用 no idiomatic 代码示例: 123456//不推荐写法private extension String {}public extension String {}open extension String {}internal extension String {}fileprivate extension String {} 规则65: no_grouping_extension只有class和protocol可以使用extension,其他类型不可使用 识别码 默认是否启用 是否支持自动更正 类型 no_grouping_extension 未启用 no idiomatic 代码示例: 123456789101112//不推荐写法enum Fruit {}extension Fruit {}extension Tea: Error {}struct Tea {}class Ham { class Spam {}}extension Ham.Spam {}extension External { struct Gotcha {}}extension External.Gotcha {} 规则66: notification_center_detachment对象移除通知只能在deinit移除self,函数中不能removeObserver(self) 识别码 默认是否启用 是否支持自动更正 类型 notification_center_detachment 启用 no lint 代码示例: 1234567891011121314151617181920//不会触发warningclass Foo { deinit { NotificationCenter.default.removeObserver(self) }}class Foo { func bar() { NotificationCenter.default.removeObserver(otherObject) }}//会触发warningclass Foo { func bar() { NotificationCenter.default.removeObserver(self) }} 规则67: number_separator数字分割线。当在大量的小数中， 应该使用下划线来作为千分位分割线 识别码 默认是否启用 是否支持自动更正 类型 number_separator 未启用 yes style 代码示例: 1234567/// 推荐使用这种形式let xxx = 1_000_000_000.000_1print(xxx)/// 不推荐使用这种形式（在swift let xxx = 1000000000.0001print(xxx) 规则68: object_literalswiftlint表示比起图片和颜色初始化，更喜欢对象初始化。因为swift初始化可以用表情，图片，颜色等，这不符合项目中的一些习惯用法 识别码 默认是否启用 是否支持自动更正 类型 object_literal 未启用 no idiomatic 代码示例: 123456789101112131415//不会触发warninglet image = #imageLiteral(resourceName: \"image.jpg\")let color = #colorLiteral(red: 0.9607843161, green: 0.7058823705, blue: 0.200000003, alpha: 1)let image = UIImage(named: aVariable)let image = UIImage(named: \"interpolated \\(variable)\")let color = UIColor(red: value, green: value, blue: value, alpha: 1)let image = NSImage(named: aVariable)let image = NSImage(named: \"interpolated \\(variable)\")let color = NSColor(red: value, green: value, blue: value, alpha: 1)//会触发warninglet image = ↓UIImage(named: \"foo\")let color = ↓UIColor(red: 0.3, green: 0.3, blue: 0.3, alpha: 1)let color = ↓UIColor(red: 100 / 255.0, green: 50 / 255.0, blue: 0, alpha: 1)let color = ↓UIColor(white: 0.5, alpha: 1) 规则69: opening_brace花括号之前应该有一个空格,且与声明在同一行 识别码 默认是否启用 是否支持自动更正 类型 opening_brace 启用 yes style 代码示例: 12345678//建议写法func abc() {}[].map() { $0 }[].map({ })if let a = b { }while a == b { }guard let a = b else { } 规则70: operator_usage_whitespace操作符使用规则， 操作符两边应该有空格。比如 “+” “-” “？？” 识别码 默认是否启用 是否支持自动更正 类型 operator_usage_whitespace 未启用 yes style 代码示例: 1234567891011//建议写法let foo = 1 + 2let foo = 1 &gt; 2let foo = !false//不推荐写法let foo = 1+2let foo = 1 + 2let foo = 1 + 2let foo = 1 + 2let foo=1+2 规则71: operator_whitespace空格/空白操作符。当定义空格操作符的时候，被定义的名字或类型两边应该各有一个单行空格操作符 识别码 默认是否启用 是否支持自动更正 类型 operator_whitespace 启用 no style 代码示例: 12345678910// 触发警告class Something: Equatable { var text: String? // \"==\"和“(lhs: Something, rhs: Something)”之间应该有一个空格 static func ==(lhs: Something, rhs: Something) -&gt; Bool { return lhs.text == rhs.text }} 规则72: overridden_super_call一些重写的方法应该调用super.(父类的)方法 识别码 默认是否启用 是否支持自动更正 类型 overridden_super_call 未启用 no lint 代码示例: 123456789101112131415/// 这样会触发警告 class VCd: UIViewController { override func viewWillAppear(_ animated: Bool) { //没有调用父类 } } /// 不会触发警告 class VCd: UIViewController { override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) } } 规则73: override_in_extension在extension中,不能重写未声明的属性和未定义的方法 识别码 默认是否启用 是否支持自动更正 类型 override_in_extension 未启用 no lint 代码示例: 12345678910//错误写法extension Person { //该属性之前未定义, 不能重写 override var age: Int { return 42 }}extension Person { //该方法之前也为定义不能重写 override func celebrateBirthday() {}} 规则74: pattern_matching_keywords…在switch-case语句中, 建议不要将case中的let和var等关键字放到元祖内 识别码 默认是否启用 是否支持自动更正 类型 pattern_matching_keywords 未启用 no idiomatic 代码示例: 123456789101112131415161718192021222324//正确写法switch foo { case let .foo(x, y): break}switch foo { case .foo(let x), .bar(let x): break}//错误写法switch foo { case (↓let x, ↓let y): break}switch foo { case .foo(↓let x, ↓let y): break}switch foo { case (.yamlParsing(↓let x), .yamlParsing(↓let y)): break}switch foo { case (↓var x, ↓var y): break}switch foo { case .foo(↓var x, ↓var y): break} 规则76: prefixed_toplevel_constant类似全局常量,建议前缀以k开头 识别码 默认是否启用 是否支持自动更正 类型 prefixed_toplevel_constant 未启用 no style 代码示例: 12345//推荐写法private let kFoo = 20.0public let kFoo = falseinternal let kFoo = \"Foo\"let kFoo = true 规则77: private_actionIBActions修饰的方法,应该都是私有的 识别码 默认是否启用 是否支持自动更正 类型 private_action 未启用 no lint 代码示例: 12345678910111213141516171819//推荐写法class Foo { @IBAction private func barButtonTapped(_ sender: UIButton) {}}struct Foo { @IBAction private func barButtonTapped(_ sender: UIButton) {}}class Foo { @IBAction fileprivate func barButtonTapped(_ sender: UIButton) {}}struct Foo { @IBAction fileprivate func barButtonTapped(_ sender: UIButton) {}}private extension Foo { @IBAction func barButtonTapped(_ sender: UIButton) {}}fileprivate extension Foo { @IBAction func barButtonTapped(_ sender: UIButton) {}} 规则78: private_outletIBOutlets修饰的属性应该都是私有的 识别码 默认是否启用 是否支持自动更正 类型 private_outlet 未启用 no lint 代码示例: 123456789101112131415//推荐写法class Foo { @IBOutlet private var label: UILabel?}class Foo { @IBOutlet private var label: UILabel!}//不推荐写法class Foo { @IBOutlet var label: UILabel?}class Foo { @IBOutlet var label: UILabel!} 规则79: private_over_fileprivateprivate比fileprivate的私有程度更高 识别码 默认是否启用 是否支持自动更正 类型 private_over_fileprivate 启用 yes idiomatic 规则80: private_unit_test私有的单元测试。被标记为private的单元测试不会被测试工具XCTest运行， 也就是说，被标记为private的单元测试会被静态跳过 识别码 默认是否启用 是否支持自动更正 类型 private_unit_test 启用 no lint 代码示例: 123456789101112131415161718192021222324252627private ↓class FooTest: XCTestCase { ...............继承于测试用例类XCTestCase, 被标记为private，所以触发warning func test1() {} internal func test2() {} public func test3() {} private func test4() {}.......另外注意这里，上面既然不会通过，那显然这里也不会通过，根本不会走这个func } internal class FooTest: XCTestCase { ......开始通过测试，因为没有被标记为private func test1() {} internal func test2() {} public func test3() {} private ↓func test4() {}................不通过，因为被标记为private } public class FooTest: XCTestCase { ..........通过 func test1() {} internal func test2() {} public func test3() {} private ↓func test4() {}.................不通过，因为被标记成private } class FooTest: XCTestCase { ..........通过 func test1() {} internal func test2() {} public func test3() {} private ↓func test4() {}.................不通过，因为被标记成private } 规则81: prohibited_super_call一些方法不应该调用父类的方法 识别码 默认是否启用 是否支持自动更正 类型 prohibited_super_call 未启用 no lint 代码示例: 1234567891011121314151617181920212223242526//以下方法不建议调用父类的方法class VC: UIViewController { override func loadView() {↓ super.loadView() }}class VC: NSFileProviderExtension { override func providePlaceholder(at url: URL,completionHandler: @escaping (Error?) -&gt; Void) {↓ self.method1() super.providePlaceholder(at:url, completionHandler: completionHandler) }}class VC: NSView { override func updateLayer() {↓ self.method1() super.updateLayer() self.method2() }}class VC: NSView { override func updateLayer() {↓ defer { super.updateLayer() } }} 规则82: protocol_property_accessors_order在协议中声明属性时，访问者的顺序应该是get set 识别码 默认是否启用 是否支持自动更正 类型 protocol_property_accessors_order 启用 yes style 代码示例: 123456789//建议protocol Foo { var bar: String { get set }} //不建议protocol Foo { var bar: String { set get }} 规则83: quick_discouraged_call在单元测试中,不建议在describe和content比保重直接调用方法和类 识别码 默认是否启用 是否支持自动更正 类型 quick_discouraged_call 未启用 no lint 规则84: quick_discouraged_focused_test在单元测试中,不建议集中测试,否则可能不能运行成功 识别码 默认是否启用 是否支持自动更正 类型 quick_discouraged_focused_test 未启用 no lint 代码示例: 123456//官方示例, 不建议class TotoTests: QuickSpec { override func spec() { ↓fdescribe(\"foo\") { } }} 规则85: quick_discouraged_pending_test单元测试中阻止未进行的测试单元 识别码 默认是否启用 是否支持自动更正 类型 quick_discouraged_pending_test 未启用 no lint 规则86: redundant_discardable_let不需要初始化方法返回结果时,建议使用: _ = Person(), 而不是:let _ = Person() 识别码 默认是否启用 是否支持自动更正 类型 redundant_discardable_let 启用 yes style 代码示例: 12345678//推荐_ = foo()if let _ = foo() { }guard let _ = foo() else { return }//不建议let _ = foo()if _ = foo() { let _ = bar() } 规则87: redundant_nil_coalescing使用可能为为nil的可选值时,建议使用: str ?? “”, ??左右两侧要有一个空格 识别码 默认是否启用 是否支持自动更正 类型 redundant_nil_coalescing 未启用 yes idiomatic 代码示例: 123456//建议写法var myVar: Int?; myVar ?? 0//不建议写法var myVar: Int? = nil; myVar ?? nilvar myVar: Int? = nil; myVar??nil 规则88: redundant_optional_initialization初始化nil变量是,不建议赋值nil 识别码 默认是否启用 是否支持自动更正 类型 redundant_optional_initialization 启用 yes idiomatic 代码示例: 1234567891011//不会触发warningvar myVar: Int?let myVar: Int? = nilvar myVar: Optional&lt;Int&gt;let myVar: Optional&lt;Int&gt; = nil//会触发warningvar myVar: Int?↓ = nilvar myVar: Optional&lt;Int&gt;↓ = nilvar myVar: Int?↓=nilvar myVar: Optional&lt;Int&gt;↓=nil 规则89: redundant_string_enum_value在定义字符串枚举的时候, 当字符串枚举值等于枚举名称时，可以不用赋值 识别码 默认是否启用 是否支持自动更正 类型 redundant_string_enum_value 启用 no idiomatic 代码示例: 123456789101112131415161718//不会触发warningenum Numbers: String { case one case two}enum Numbers: Int { case one = 1 case two = 2}//会触发warningenum Numbers: String { case one = ↓\"one\" case two = ↓\"two\"}enum Numbers: String { case one = ↓\"one\", two = ↓\"two\"} 规则90: redundant_void_return当函数返回值为Void时,建议不谢返回值, 定义常量或者变量的时候可以 识别码 默认是否启用 是否支持自动更正 类型 redundant_void_return 启用 yes idiomatic 代码示例: 12345678910111213141516//不会触发warningfunc foo() {}func foo() -&gt; Int {}func foo() -&gt; Int -&gt; Void {}func foo() -&gt; VoidResponselet foo: Int -&gt; Void//会触发warningfunc foo()↓ -&gt; Void {}protocol Foo { func foo()↓ -&gt; Void}func foo()↓ -&gt; () {}protocol Foo { func foo()↓ -&gt; ()} 规则91: required_enum_case定义的枚举,必须有与其对应的操作实现 识别码 默认是否启用 是否支持自动更正 类型 required_enum_case 未启用 no lint 规则92: return_arrow_whitespaceswiftlint推荐返回箭头和返回类型应该被空格分开 识别码 默认是否启用 是否支持自动更正 类型 return_arrow_whitespace 启用 yes style 代码示例: 12345678910//推荐写法func abc() -&gt; Int {}func abc() -&gt; [Int] {}//不建议写法func abc()↓-&gt;Int {}func abc()↓-&gt;[Int] {}func abc()↓-&gt;(Int, Int) {}func abc()↓-&gt; Int {}func abc()↓ -&gt;Int {} 规则93: shorthand_operator在swiftlint中， 就是我们常用的简洁操作运算符，比如：+= ， -=， *=， /= 等等。在swiftlint中，在做一些赋值操作的时候，推荐使用简短操作符 识别码 默认是否启用 是否支持自动更正 类型 shorthand_operator 启用 no style 代码示例: 123456789/// 不推荐使用var value = 4value = value / 2print(value)/// 推荐使用var value = 4value /= 2print(value) 规则94: single_test_class单元测试中,测试文件应该包含一个QuickSpec或XCTestCase类 识别码 默认是否启用 是否支持自动更正 类型 single_test_class 未启用 no style 规则95: sorted_first_last在获取某数组中最大最小值时,建议使用min和max函数,而不是sorted().first和sorted().lase 识别码 默认是否启用 是否支持自动更正 类型 sorted_first_last 未启用 no style 代码示例: 12 规则96: aaa… 识别码 默认是否启用 是否支持自动更正 类型 aaa 未启用 no style 代码示例: 12345678910111213//建议let min = myList.min()let min = myList.min(by: { $0 &lt; $1 })let min = myList.min(by: &gt;)let min = myList.max()let min = myList.max(by: { $0 &lt; $1 })//不建议myList.sorted().firstmyList.sorted(by: { $0.description &lt; $1.description }).firstmyList.sorted(by: &gt;).firstmyList.map { $0 + 1 }.sorted().firstmyList.sorted(by: someFunction).first 规则97: sorted_imports分类/有序导入。 这个属性有些奇怪， 要求导入的时候导入的类要按顺序导入 识别码 默认是否启用 是否支持自动更正 类型 sorted_imports 未启用 yes style 代码示例: 123456789//建议写法import AAAimport BBBimport CCCimport DDDimport Alamofireimport API 规则98: statement_position陈述句位置， 这里主要指的是 else 和 catch 前面要加一个空格， 也不能大于1个空格， 否则就会触发警告 识别码 默认是否启用 是否支持自动更正 类型 statement_position 启用 yes style 代码示例: 1234567891011121314151617181920212223242526/// 没有空格，触发warninglet number = \"long\"if number.isEmpty { print(\"为空\")}else {.............................注意这里 print(\"不为空\")}/// 这里也会触发warning， 因为else if换行了let number = \"long\"if number.isEmpty { print(\"为空\")}else if number.contains(\"long\") {............................注意这里 print(\"不为空\")} else { print(\"s\")}/// 正确的写法let number = \"long\"if number.isEmpty { print(\"为空\")} else { print(\"不为空\")} 规则99: strict_fileprivateextension中不建议使用fileprivate 修饰方法和属性 识别码 默认是否启用 是否支持自动更正 类型 strict_fileprivate 未启用 no idiomatic 规则100: superfluous_disable_command被禁用的规则不会在禁用区域触发警告 识别码 默认是否启用 是否支持自动更正 类型 superfluous_disable_command 启用 no lint 文中如有不足之处请多指教 持续更新中…..","link":"/2018/03/10/SwiftLint代码规范属性说明02/"},{"title":"iOS出门必备之CoreAnimation(核心动画)","text":"前段时间接触到了一个牛逼的动画框架POP,本来想来装装逼,突然发现,苹果大大的CoreAnimation我还不会用呢! 依稀记得乔帮主在2007年的WWDC大会上亲自为你演示Core Animation的强大：点击查看视频(不好意思,又装逼了) 言归正传,我只是来温习一下CoreAnimation,还望路过的大神不要吐槽我太low GitHub项目地址 Core Animation简介 Core Animation，中文翻译为核心动画，它是一组非常强大的动画处理API，使用它能做出非常炫丽的动画效果，而且往往是事半功倍。也就是说，使用少量的代码就可以实现非常强大的功能。 Core Animation可以用在Mac OS X和iOS平台。 Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程。 要注意的是，Core Animation是直接作用在CALayer上的，并非UIView 通过调用CALayer的addAnimation:forKey:方法增加CAAnimation对象到CALayer中，这样就能开始执行动画了 通过调用CALayer的removeAnimationForKey:方法可以停止CALayer中的动画 Core Animation及其相关属性 要想执行动画，就必须初始化一个CAAnimation对象。 一般情况下，我们使用的比较多的是CAAnimation的子类，因此，先大致看看CAAnimation的继承结构 黑线代表继承，黑色文字代表类名，白色文字代表属性。其中CAMediaTiming是一个协议(protocol) 需要注意 CAAnimation是所有动画类的父类，但是它不能直接使用，应该使用它的子类 CAPropertyAnimation也是不能直接使用的，也要使用它的子类 能用的动画类只剩下4个：CABasicAnimation、CAKeyframeAnimation、CATransition、CAAnimationGroup 常用属性1). removedOnCompletion：默认为true，代表动画执行完毕后就从图层上移除 图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为false，不过还要设置fillMode为kCAFillModeForwards 2). timingFunction：控制动画运行的节奏 1234567891011121314151617181920/** timingFunction可选的值 **/@available(iOS 2.0, *)public let kCAMediaTimingFunctionLinear: String//1.(匀速): 在整个动画时间内动画都是以一个相同的速度来改变@available(iOS 2.0, *)public let kCAMediaTimingFunctionEaseIn: String//2. (渐进): 缓慢进入, 加速离开@available(iOS 2.0, *)public let kCAMediaTimingFunctionEaseOut: String//3. (渐出): 快速进入, 减速离开@available(iOS 2.0, *)public let kCAMediaTimingFunctionEaseInEaseOut: String//4. (渐进渐出): 缓慢进入, 中间加速, 减速离开@available(iOS 3.0, *)public let kCAMediaTimingFunctionDefault: String//5. (默认): 效果基本等同于EaseOut(渐出) 3). fillMode决定当前对象在非active时间段的行为。 要想fillMode有效，需设置removedOnCompletion = false fillMode可选的值 12345678910111213141516/* `fillMode' options. */@available(iOS 2.0, *)public let kCAFillModeForwards: String//1. 当动画结束后，layer会一直保持着动画最后的状态@available(iOS 2.0, *)public let kCAFillModeBackwards: String//2. 设置为该值，将会立即执行动画的第一帧，不论是否设置了 beginTime属性。观察发现，设置该值，刚开始视图不见，还不知道应用在哪里@available(iOS 2.0, *)public let kCAFillModeBoth: String//3. 该值是 kCAFillModeForwards 和 kCAFillModeBackwards的组合状态; 动画加入后开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态@available(iOS 2.0, *)public let kCAFillModeRemoved: String//4. 默认值，动画将在设置的 beginTime 开始执行（如没有设置beginTime属性，则动画立即执行），动画执行完成后会将layer的改变恢复原状 4). delegate：动画代理，用来监听动画的执行过程 12345678910public protocol CAAnimationDelegate : NSObjectProtocol { // 动画开始执行的时候触发这个方法 @available(iOS 2.0, *) optional public func animationDidStart(_ anim: CAAnimation) // 动画执行完毕的时候触发这个方法 @available(iOS 2.0, *) optional public func animationDidStop(_ anim: CAAnimation, finished flag: Bool)} 5). 其他相关属性 123456789duration 动画的时长repeatCount 重复的次数。不停重复设置为 HUGE_VALFrepeatDuration 设置动画的时间。在该时间内动画一直执行，不计次数。beginTime 指定动画开始的时间。从开始延迟几秒的话，设置为【CACurrentMediaTime() + 秒数】 的方式timingFunction 设置动画的速度变化autoreverses 动画结束时是否执行逆动画fromValue 所改变属性的起始值(Swift中为Any类型,OC中要包装成NSValue对象)toValue 所改变属性的结束时的值(类型与fromValue相同)byValue 所改变属性相同起始值的改变量(类型与fromValue相同) CABasicAnimation CABasicAnimation是CAPropertyAnimation的子类，使用它可以实现一些基本的动画效果，它可以让CALayer的某个属性从某个值渐变到另一个值。下面就用CABasicAnimation实现几个简单的动画 平移动画方法一: 改变label的position12345678let caBasic = CABasicAnimation(keyPath: \"position\")caBasic.duration = 2caBasic.fromValue = redLabel.layer.positioncaBasic.toValue = CGPoint(x: kScreenWidth - 50, y: 200)caBasic.delegate = selfcaBasic.isRemovedOnCompletion = falsecaBasic.fillMode = kCAFillModeForwardsredLabel.layer.add(caBasic, forKey: \"redLabel1\") 初始化方法中是@”position”，说明要修改的是CALayer的position属性，也就是会执行平移动画 默认情况下，动画执行完毕后，动画会自动从CALayer上移除，CALayer又会回到原来的状态。为了保持动画执行后的状态，可以加入第6、7行代码 第8行后面的@”redLabel1”是给动画对象起个名称，以后可以调用CALayer的removeAnimationForKey:方法根据动画名称停止相应的动画 遵循的代理方法 123456789101112131415extension ViewController: CAAnimationDelegate { //开始执行 func animationDidStart(_ anim: CAAnimation) { print(\"开始动画--layer:\", redLabel.layer.position) } //结束之行 func animationDidStop(_ anim: CAAnimation, finished flag: Bool) { print(\"结束动画--layer:\", redLabel.layer.position) }}//打印结果为://开始动画--layer: (35.0, 213.0)//结束动画--layer: (35.0, 213.0) 从打印信息可以看出，实际上，动画执行完毕后，并没有真正改变CALayer的position属性的值！ 方法二.12345 let basic = CABasicAnimation(keyPath: \"transform\")basic.duration = 2let form = CATransform3DMakeTranslation(350, 400, 0)basic.toValue = formblueLabel.layer.add(basic, forKey: \"blueLabel\") 旋转动画123456let basic1 = CABasicAnimation(keyPath: \"transform\")basic1.duration = 1basic1.toValue = CATransform3DMakeRotation(0.25, 0, 0, 1)basic1.isRemovedOnCompletion = falsebasic1.fillMode = kCAFillModeForwardsblueLabel.layer.add(basic1, forKey: \"basic1\") 可以不用设置fromValue，这里只设置了toValue 缩放动画 CALayer的宽度从0.5倍变为2倍 CALayer的高度从0.5倍变为1.5倍 1234567let basic1 = CABasicAnimation(keyPath: \"transform\")basic1.duration = 1basic1.toValue = CATransform3DMakeScale(0.5, 0.5, 1)basic1.toValue = CATransform3DMakeScale(2, 1.5, 1)basic1.isRemovedOnCompletion = falsebasic1.fillMode = kCAFillModeForwardsblueLabel.layer.add(basic1, forKey: \"basic1\") CABasicAnimation虽然能够做很多基本的动画效果，但是有个局限性，只能让CALayer的属性从某个值渐变到另一个值，仅仅是在2个值之间渐变 总结一些常用的animationKeyPath值的 值 说明 使用形式 transform.scale 比例转化 0.5 transform.scale.x 宽的比例 0.5 transform.rotation.x 围绕x轴旋转 @(M_PI_4)(OC), 0.25(Swift) cornerRadius 圆角的设置 30 backgroundColor 背景颜色的变化 UIColor.purpleColor.cgColor bounds 大小，中心不变 CGRect position 位置(中心点的改变) CGPoint contents 内容，比如UIImageView的图片 imageAnima.toValue = UIImage(named: “toImage”)?.cgImage opacity 透明度 0.7 contentsRect.size.width 横向拉伸缩放 最好是0~1之间的 CAKeyframeAnimation——关键帧动画 关键帧动画，也是CAPropertyAnimation的子类，与CABasicAnimation的区别是： CABasicAnimation只能从一个数值（fromValue）变到另一个数值（toValue） 而CAKeyframeAnimation会使用一个Array保存这些数值 属性说明： values：上述的Array对象。里面的元素称为“关键帧”(keyframe)。动画对象会在指定的时间（duration）内，依次显示values数组中的每一个关键帧 path：可以设置一个CGPathRef、CGMutablePathRef，让图层按照路径轨迹移动。path只对CALayer的anchorPoint和position起作用。如果设置了path，那么values将被忽略 keyTimes：可以为对应的关键帧指定对应的时间点，其取值范围为0到1.0，keyTimes中的每一个时间值都对应values中的每一帧。如果没有设置keyTimes，各个关键帧的时间是平分的 calculationMode: 该属性决定了物体在每个子路径下是跳着走还是匀速走，跟timeFunctions属性有点类似 kCAAnimationLinear默认值,表示当关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算; kCAAnimationDiscrete 离散的,就是不进行插值计算,所有关键帧直接逐个进行显示; kCAAnimationPaced 使得动画均匀进行,而不是按keyTimes设置的或者按关键帧平分时间,此时keyTimes和timingFunctions`无效; kCAAnimationCubic 对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过tensionValues,continuityValues,biasValues来进行调整自定义主要目的是使得运行的轨迹变得圆滑; kCAAnimationCubicPaced 看这个名字就知道和kCAAnimationCubic有一定联系,其实就是在kCAAnimationCubic的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,此时keyTimes以及timingFunctions也是无效的. CABasicAnimation可看做是只有2个关键帧的CAKeyframeAnimation values方式1234567let key = CAKeyframeAnimation(keyPath: \"position\")key.duration = 3key.repeatCount = HUGE //无线循环key.calculationMode = kCAAnimationPacedkey.values = [redLabel.frame.origin, CGPoint(x: 180, y: 70), CGPoint(x: 180, y: 200), redLabel.frame.origin]key.keyTimes = [NSNumber(value: 0.0), NSNumber(value: 0.6), NSNumber(value: 0.7), NSNumber(value: 0.8)]redLabel.layer.add(key, forKey: \"key\") CASpringAnimation CASpringAnimation是iOS 9 新出的 CASpringAnimation 继承于CABaseAnimation CASpringAnimation是苹果专门解决开发者关于弹簧动画的这个需求而封装的类。 CASpringAnimation相关属性123456789101112131415//1. 质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大, 默认值: 1open var mass: CGFloat//2. 刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快(默认值: 100)open var stiffness: CGFloat//3. 阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快(默认值: 10)open var damping: CGFloat//4. 初始速率，动画视图的初始速度大小, 默认0//速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反(默认值: 0)open var initialVelocity: CGFloat//5. 估算时间 返回弹簧动画到停止时的估算时间，根据当前的动画参数估算(只读)open var settlingDuration: CFTimeInterval { get } 示例代码123456789let spring = CASpringAnimation(keyPath: \"position.y\")spring.mass = 5spring.stiffness = 100spring.damping = 5spring.initialVelocity = 2spring.fromValue = blueLabel.layer.position.yspring.toValue = kScreenHeight - 150spring.duration = spring.settlingDurationblueLabel.layer.add(spring, forKey: \"spring\") CAAnimationGroup动画组 是CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行 属性说明： animations：用来保存一组动画对象的Array 默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间 代码示例: 同时执行：平移、缩放、位移动画 -&gt; 使用动画组 12345678910111213141516171819202122232425262728//动画组fileprivate func getCAAnimationGroup(){ //0. 初始化动画组 let group = CAAnimationGroup() //1. 平移动画 let basic1 = CABasicAnimation(keyPath: \"position\") basic1.fromValue = blueLabel.layer.position basic1.toValue = CGPoint(x: CGFloat(arc4random_uniform(200)), y: CGFloat(arc4random_uniform(500))) //2. 缩放动画 let basic2 = CABasicAnimation(keyPath: \"transform.scale\") var scale: CGFloat = 0.1 scale = scale &lt; 1 ? 1.5 : 0.5 basic2.toValue = scale //3. 旋转动画 let basic3 = CABasicAnimation(keyPath: \"transform.rotation\") basic3.toValue = CGFloat(arc4random_uniform(360)) / 180.0 //4. 添加到动画组 group.animations = [basic1, basic2, basic3] //取消反弹 group.isRemovedOnCompletion = false group.fillMode = kCAFillModeForwards group.duration = 0.5 blueLabel.layer.add(group, forKey: \"group\")} 转场动画——CATransition CATransition是CAAnimation的子类，用于做转场动画，能够为layer层提供移出屏幕和移入屏幕的动画效果。 iOS比Mac OS X的转场动画效果少一点UINavigationController就是通过CATransition实现了将控制器的视图推入屏幕的动画效果 动画属性: type：动画过渡类型 subtype：动画过渡方向 startProgress：动画起点(在整体动画的百分比) endProgress：动画终点(在整体动画的百分比) type和subtype属性说明12345678910111213141516171819202122232425262728293031323334/* type类型 */@available(iOS 2.0, *)public let kCATransitionFade: String//交叉淡化过渡@available(iOS 2.0, *)public let kCATransitionMoveIn: String//新视图移到旧视图上面@available(iOS 2.0, *)public let kCATransitionPush: String//新视图把旧视图推出去@available(iOS 2.0, *)public let kCATransitionReveal: String//将旧视图移开,显示下面的新视图/* subtypes类型 */@available(iOS 2.0, *)public let kCATransitionFromRight: String//从右侧转场@available(iOS 2.0, *)public let kCATransitionFromLeft: String//从左侧转场@available(iOS 2.0, *)public let kCATransitionFromTop: String//从上部转场@available(iOS 2.0, *)public let kCATransitionFromBottom: String//从底部转场 注意： 除了上述四种效果之外,还有很多私有API效果，使用的时候要小心，可能会导致app审核不被通过 使用的时候要以字符串的形式 12345678cube //立方体翻滚效果oglFlip //上下左右翻转效果suckEffect //收缩效果，如一块布被抽走(不支持过渡方向)rippleEffect //滴水效果(不支持过渡方向)pageCurl //向上翻页效果pageUnCurl //向下翻页效果cameraIrisHollowOpen //相机镜头打开效果(不支持过渡方向)cameraIrisHollowClose //相机镜头关上效果(不支持过渡方向) 效果参考 代码示例: 展示立方体翻滚效果的图片浏览 初始化变量123//初始化变量fileprivate var imageView = UIImageView(frame: UIScreen.main.bounds)fileprivate var currentIndex = 0 需要在viewDidLoad中调用一下方法123456789101112131415//转场动画 fileprivate func imageCATransition(){ //0.初始化ImageView imageView.isUserInteractionEnabled = true imageView.image = UIImage(named: \"0.jpg\") view.addSubview(imageView) //1. 添加滑动手势 let left = UISwipeGestureRecognizer(target: self, action: #selector(leftSwipe(gesture:))) left.direction = .left imageView.addGestureRecognizer(left) let right = UISwipeGestureRecognizer(target: self, action: #selector(rightSwipe(gesture:))) right.direction = .right imageView.addGestureRecognizer(right) } 滑动后执行的方法1234567891011121314151617181920212223242526272829//MARK: 手势相关方法//左滑@objc fileprivate func leftSwipe(gesture: UIGestureRecognizer) { print(\"左滑动\") transitionAnimation(isNext: true)}//右滑@objc fileprivate func rightSwipe(gesture: UIGestureRecognizer) { print(\"右滑动\") transitionAnimation(isNext: false)}//设置转场动画fileprivate func transitionAnimation(isNext: Bool){ let transition = CATransition() transition.type = kCATransitionFade transition.subtype = isNext ? kCATransitionFromRight : kCATransitionFromLeft transition.duration = 1 imageView.image = getImage(isNext) imageView.layer.add(transition, forKey: \"transition\")}//获取下/上一张图片fileprivate func getImage(_ isNext: Bool) -&gt; UIImage { currentIndex = isNext ? currentIndex + 1 : currentIndex - 1 currentIndex = currentIndex &lt; 0 ? 7 : currentIndex currentIndex = currentIndex &gt; 7 ? 0 : currentIndex return UIImage(named: \"\\(currentIndex)\" + \".jpg\")!} 总结 核心动画给我们展示的只是一个假象，layer的的frame、bounds、position并不会在动画完毕之后发生改变。 UIView封装的动画，会使会真实修改view的一些属性 以上就是小编总结的关于Core Animation核心动画的相关分类 总结的知识点比较简单, 个人感觉有点low 如有不足之处,还望路过的大神多多指教","link":"/2017/10/12/iOS出门必备之CoreAnimation(核心动画)/"},{"title":"SwiftLint代码规范属性说明01","text":"下面来具体介绍一下SwiftLint的具体的代码规则的相关说明 Github 公布的 Swift 代码规范–原文 Github 公布的 Swift 代码规范–中文 官方的SwiftLint规则说明 规则1: closing_brace在使用Swift 3.2或更高版本时，首选系统的KVO 的API和keypath 识别码 默认是否启用 是否支持自动更正 类型 block_based_kvo 启用 no idiomatic 官方示例: 1234567891011//编译通过let observer = foo.observe(\\.value, options: [.new]) { (foo, change) in print(change.newValue)}//会触发警告class Foo: NSObject { override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {}} 规则2: class_delegate_protocol委托协议应该只是class类，可以被弱引用(官方解释,先放出官方示例吧) 识别码 默认是否启用 是否支持自动更正 类型 class_delegate_protocol 启用 no lint 示例: 123456789101112131415//不会触发warningprotocol FooDelegate: class {}protocol FooDelegate: class, BarDelegate {}protocol Foo {}class FooDelegate {}@objc protocol FooDelegate {}@objc(MyFooDelegate)protocol FooDelegate {}protocol FooDelegate: BarDelegate {}protocol FooDelegate: AnyObject {}protocol FooDelegate: NSObjectProtocol {}//会触发warningprotocol FooDelegate {}protocol FooDelegate: Bar {} 规则3: closing_brace类似小括号包含大括号的不能用空格 识别码 默认是否启用 是否支持自动更正 类型 closing_brace 启用 yes style 具体示例: 1234567891011//不会触发warning[1, 2].map({ $0 })[1, 2].map( { $0 })//会触发warning[1, 2].map({ $0 } )[1, 2].map({ $0 } )[1, 2].map( { $0 }) 规则4: closure_end_indentation闭包的封闭端和开始端有相同的缩进, 意思就是 大括号（一般是方法）上下对齐的问题，这样使code看起来更加整洁 识别码 默认是否启用 是否支持自动更正 类型 closure_end_indentation 未启用 no style 具体示例: 123456789101112131415161718192021//不会触发closure_end_indentation[1, 2].map { $0 + 1 }//不会触发closure_end_indentationSignalProducer(values: [1, 2, 3]) .startWithNext { number in print(number) }//不会触发closure_end_indentationfunction { ..........}//会触发closure_end_indentationSignalProducer(values: [1, 2, 3]) .startWithNext { number in print(number)}//不会触发closure_end_indentationfunction { .......... } 规则5: closure_parameter_position闭包参数位置， 闭包参数应该和大括号左边在同一行, 推荐使用 识别码 默认是否启用 是否支持自动更正 类型 closure_parameter_position 启用 no style 具体示例: 12345678910111213141516171819202122232425/// number 和 { 在同一行, 不会触发warninglet names = [1, 2, 3]names.forEach { (number) in print(number)}let names = [1, 2, 3]names.map { number in number + 1}/// 这样不行，违背 closure_parameter_position规则, 触发warninglet names = [1, 2, 3]names.forEach { (number) in print(number)} let names = [1, 2, 3] names.map { number in number + 1 } 规则6: closure_spacing在闭包的{}中间要有一个空格,如map({ $0 }) 识别码 默认是否启用 是否支持自动更正 类型 closure_spacing 未启用 yes style 以下示例: 123456789不会触发警告map({ $0 })[].map ({ $0.description })//会触发警告map({$0 })map({ $0})map({$0})[].map ({$0.description }) 规则7: colon冒号的使用， swiftlint的这个colon属性规则很简单，要求“ ：”紧靠所定义的常量或变量等，必须没有空格，与所指定的类型之间必须只有一个空格，多一个或少一个都不行，如果是用在Dictionary中，则要求紧靠Key，与Value之间必须有且仅有一个空格。这个规则我觉得应该强制推荐使用 识别码 默认是否启用 是否支持自动更正 类型 colon 启用 yes style 具体示例: 12345678910//不会触发警告let abc: String = \"jun\"let abc = [1: [3: 2], 3: 4]let abc = [1: [3: 2], 3: 4]//会触发警告let jun:Voidlet jun : Voidlet jun :Voidlet jun: Void 规则8: comma逗号使用只要遵循“前不离身后退一步”就行了，这个也强制推荐使用 识别码 默认是否启用 是否支持自动更正 类型 comma 启用 yes style 具体示例: 12345//不触发警告[a, b, c, d]//触发警告[a ,b] 规则9: compiler_protocol_init编译器协议初始化, 不建议.init等初始化方式, 建议使用简单的初始化形式 识别码 默认是否启用 是否支持自动更正 类型 compiler_protocol_init 启用 no lint 官方示例: 123456789101112131415public static let description = RuleDescription( identifier: \"compiler_protocol_init\", name: \"Compiler Protocol Init\", description: \"The initializers declared in compiler protocols such as `ExpressibleByArrayLiteral` \" + \"shouldn't be called directly.\", kind: .lint, nonTriggeringExamples: [ \"let set: Set&lt;Int&gt; = [1, 2]\\n\", \"let set = Set(array)\\n\" ], triggeringExamples: [ \"let set = ↓Set(arrayLiteral: 1, 2)\\n\", \"let set = ↓Set.init(arrayLiteral: 1, 2)\\n\" ]) 规则10: conditional_returns_on_newline条件语句不能写在同一行, 条件返回语句应该在新的一行。 当有条件返回的时候应该换行返回，而不是在同一行 识别码 默认是否启用 是否支持自动更正 类型 conditional_returns_on_newline 未启用 no style 具体示例: 123456789101112/// swiftlint 不推荐的写法, 否则会触发warningif true { return }guard true else { return }/// swiftlint 推荐的写法if true { return}guard true else { return } 规则11: contains_over_first_not_nil类似first函数不能判断是否为nil 识别码 默认是否启用 是否支持自动更正 类型 contains_over_first_not_nil 未启用 no performance 具体示例: 1234567//推荐写法let first = myList.first(where: { $0 % 2 == 0 })let first = myList.first { $0 % 2 == 0 }//不推荐写法myList.first { $0 % 2 == 0 } != nilmyList.first(where: { $0 % 2 == 0 }) != nil 规则12: control_statement控制语句, for，while，do，catch语句中的条件不能包含在()中 识别码 默认是否启用 是否支持自动更正 类型 control_statement 启用 no style 具体示例: 12345678//建议写法if condition {if (a, b) == (0, 1) {//不建议写法if (condition) {if(condition) {if ((a || b) &amp;&amp; (c || d)) { 规则13: custom_rules自定义规则。 这个属性可以通过提供正则表达式来创建自定义规则， 可选指定语法类型搭配， 安全、级别和要陈列的什么信息。 这个属性只要熟悉使用正则表达式的人使用，目前可以不适用 识别码 默认是否启用 是否支持自动更正 类型 custom_rules 启用 no style 规则14: cyclomatic_complexity循环复杂度。函数体的复杂度应该要限制，这个属性主要约束条件句、循环句中的循环嵌套问题， 当嵌套太多的循环时，则会触发swiftlint中的warning和error，当达到10个循环嵌套时就会报warning，达到20个循环嵌套时就会报error 识别码 默认是否启用 是否支持自动更正 类型 cyclomatic_complexity 启用 no metrics 规则15: discarded_notification_center_observer当使用注册的通知时, 应该存储返回的观察者, 便于用完之后移除通知 识别码 默认是否启用 是否支持自动更正 类型 discarded_notification_center_observer 启用 no lint 代码示例: 123456789101112131415161718//推荐写法let foo = nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil) { }let foo = nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil, using: { })func foo() -&gt; Any { return nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil, using: { })}//不推荐写法nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil) { }nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil, using: { })@discardableResult func foo() -&gt; Any { return nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil, using: { })} 规则16: discouraged_direct_init阻止直接初始化导致的错误类型, 有类方法的,用类方法初始化(不建议直接init初始化) 识别码 默认是否启用 是否支持自动更正 类型 discouraged_direct_init 启用 no lint 代码示例: 12345678910//建议写法let foo = UIDevice.currentlet foo = Bundle.mainlet foo = Bundle(path: \"bar\")let foo = Bundle(identifier: \"bar\")//不建议写法let foo = UIDevice()let foo = Bundle()let foo = bar(bundle: Bundle(), device: UIDevice()) 规则17: discouraged_optional_boolean不建议使用可选布尔值 识别码 默认是否启用 是否支持自动更正 类型 discouraged_optional_boolean 未启用 no idiomatic 代码示例: 1234567891011//建议写法var foo: Boolvar foo: [String: Bool]var foo: [Bool]let foo: Bool = true//不建议写法var foo: Bool?var foo: [String: Bool?]var foo: [Bool?]let foo: Bool? = nil 规则18: discouraged_object_literal优先使用对象初始化方法, 不建议使用代码块初始化 识别码 默认是否启用 是否支持自动更正 类型 discouraged_object_literal 未启用 no idiomatic 代码示例: 123//不建议写法let white = #colorLiteral(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0)let image = ↓#imageLiteral(resourceName: \"image.jpg\") 规则19: dynamic_inline避免一起使用 dynamic 和 @inline(_ _always)， 否则报 error 识别码 默认是否启用 是否支持自动更正 类型 dynamic_inline 启用 no lint 代码示例: 12345678910111213141516171819202122232425/// 正确的做法class LangKe { dynamic func myFunction() { }}class LangKe { @inline(__always) func myFunction() { }}class LangKe { @inline(never) dynamic func myFunction() { }}/// 只要同时使用 dynamic 和 @inline(_ _always)都报错 error！！！class LangKe { @inline(__always) public dynamic func myFunction() { }} 规则20: array_init序列转化成数组时, 优先使用数组转化, 而不是seq.map {$ 0}将序列转换为数组 识别码 默认是否启用 是否支持自动更正 类型 array_init 未启用 no lint 官方示例: 1234567891011121314151617181920212223242526272829303132333435363738public static let description = RuleDescription( identifier: \"array_init\", name: \"Array Init\", description: \"Prefer using Array(seq) than seq.map { $0 } to convert a sequence into an Array.\", kind: .lint, //以下示例不会触发警告 nonTriggeringExamples: [ \"Array(foo)\\n\", \"foo.map { $0.0 }\\n\", \"foo.map { $1 }\\n\", \"foo.map { $0() }\\n\", \"foo.map { ((), $0) }\\n\", \"foo.map { $0! }\\n\", \"foo.map { $0! /* force unwrap */ }\\n\", \"foo.something { RouteMapper.map($0) }\\n\" ], //以下示例会触发警告 triggeringExamples: [ \"↓foo.map({ $0 })\\n\", \"↓foo.map { $0 }\\n\", \"↓foo.map { return $0 }\\n\", \"↓foo.map { elem in\\n\" + \" elem\\n\" + \"}\\n\", \"↓foo.map { elem in\\n\" + \" return elem\\n\" + \"}\\n\", \"↓foo.map { (elem: String) in\\n\" + \" elem\\n\" + \"}\\n\", \"↓foo.map { elem -&gt; String in\\n\" + \" elem\\n\" + \"}\\n\", \"↓foo.map { $0 /* a comment */ }\\n\" ]) 规则21: empty_count建议使用isEmpty判断,而不是使用count==0判断 识别码 默认是否启用 是否支持自动更正 类型 empty_count 未启用 no performance 代码示例: 1234567891011121314/// swiftlint不建议这样使用let number = \"long\"if number.characters.count == 0 { print(\"为空\")} else { print(\"不为空\")}/// swiftlint建议这种正式风格if number.isEmpty { print(\"为空\")} else { print(\"不为空\")} 规则22: empty_enum_arguments当枚举与关联类型匹配时，如果不使用它们，参数可以省略 识别码 默认是否启用 是否支持自动更正 类型 empty_enum_arguments 启用 yes style 代码示例: 123456789101112131415161718192021222324252627//SwiftLint建议写法switch foo { case .bar: break}switch foo { case .bar(let x): break}switch foo { case let .bar(x): break}switch (foo, bar) { case (_, _): break}switch foo { case \"bar\".uppercased(): break}//SwiftLint不建议写法switch foo { case .bar(_): break}switch foo { case .bar(): break}switch foo { case .bar(_), .bar2(_): break} 规则23: empty_parameters闭包参数为空时,建议使用() -&gt;Void, 而不是Void -&gt;Void 识别码 默认是否启用 是否支持自动更正 类型 empty_parameters 启用 yes style 代码示例: 12345678910111213/// 01 不会触发warninglet abc: () -&gt; Voidfunc foo(completion: () -&gt; Void) {}/// 02 直接报错let bcd: Void -&gt; Voidfunc foo(completion: Void -&gt; Void) {} 规则24: empty_parentheses_with_trailing_closure在使用尾随闭包的时候， 应该尽量避免使用空的圆括号 识别码 默认是否启用 是否支持自动更正 类型 empty_parentheses_with_trailing_closure 启用 yes style 1234567891011121314151617//不会触发warning[1, 2].map { $0 + 1 }[1, 2].map({ $0 + 1 })[1, 2].reduce(0) { $0 + $1 }[1, 2].map { number in number + 1 }//会触发warning[1, 2].map() { $0 + 1 }[1, 2].map( ) { $0 + 1 }[1, 2].map() { number in number + 1 }[1, 2].map( ) { number in number + 1 } 规则26: explicit_acl…所有属性和方法的声明, 都应该明确指定修饰关键字 识别码 默认是否启用 是否支持自动更正 类型 explicit_acl 未启用 no idiomatic 官方代码示例: 123456789101112131415161718192021//非触发示例internal enum A {}public final class B {}private struct C {}internal func a() { let a = }private struct C { let d = 5 }internal class A { deinit {} }internal protocol A { func b() var c: Int}//触发示例enum A {}final class B {}internal struct C { let d = 5 }public struct C { let d = 5 }func a() {}internal let a = 0func b() {} 规则27: explicit_type_interface声明的属性应该明确其类型, 如: var myVar: Int = 0 识别码 默认是否启用 是否支持自动更正 类型 explicit_type_interface 未启用 no idomatic 代码示例: 1234567891011//推荐写法class Foo { var myVar: Int? = 0 let myLet: Int? = 0}//不建议写法class Foo { var myVar = 0 let myLet = 0} 规则28: extension_access_modifier在自定义类中,推荐使用extension扩展 识别码 默认是否启用 是否支持自动更正 类型 extension_access_modifier 未启用 no idiomatic 规则29: no_extension_access_modifier在extension扩展前面,不建议使用(fileprivate, public)等修饰符 识别码 默认是否启用 是否支持自动更正 类型 no_extension_access_modifier 未启用 no idiomatic 代码示例: 123456//不建议以下写法private extension String {}public extension String {}open extension String {}internal extension String {}fileprivate extension String {} 规则30: fallthroughswitch语句中不建议使用fallthrough 识别码 默认是否启用 是否支持自动更正 类型 fallthrough 启用 no idiomatic 代码示例: 12345678910111213//推荐写法switch foo {case .bar, .bar2, .bar3: something()}//不建议写法switch foo {case .bar: fallthroughcase .bar2: something()} 规则31: fatal_error_message执行fatalError错误时,建议有一个提示信息; 如:fatalError(“Foo”) 识别码 默认是否启用 是否支持自动更正 类型 fatal_error_message 未启用 no idiomatic 代码示例: 123456789//推荐写法required init?(coder aDecoder: NSCoder) { fatalError(\"init(coder:) has not been implemented\")}//不建议required init?(coder aDecoder: NSCoder) { fatalError(\"\")} 规则32: file_header文件头。新建的文件开始的注释应该一样 识别码 默认是否启用 是否支持自动更正 类型 aaa 未启用 no style 代码示例: 123456789101112131415161718/// 不会触发warning/// 如果我新建一个工程，在ViewController.swift文件中， 开始的注释应该是：// ViewController.swift// SwiftLint//// Created by langke on 17/1/17.// Copyright © 2017年 langke. All rights reserved.//改变一下变为：//// MyViewController.swift...................由于这里和外面的文件名不一样，所以触发warning（实际上在swift 3.0上测试这个属性暂时没有任何作用！！）// SwiftLint//// Created by langke on 17/1/17.// Copyright © 2017年 langke. All rights reserved................官方terminal表示，Copyright和Created没有对齐，也会触发warning！！！// 规则33: file_length文件内容行数, 超过400行warning, 超过1000行给error 识别码 默认是否启用 是否支持自动更正 类型 file_length 启用 no metrics 规则34: first_where不建议在使用filter和map函数后直接使用.first 识别码 默认是否启用 是否支持自动更正 类型 first_where 未启用 no performance 官方代码示例: 123456789101112131415161718192021222324public static let description = RuleDescription( identifier: \"first_where\", name: \"First Where\", description: \"Prefer using `.first(where:)` over `.filter { }.first` in collections.\", kind: .performance, //不会触发警告 nonTriggeringExamples: [ \"kinds.filter(excludingKinds.contains).isEmpty &amp;&amp; kinds.first == .identifier\\n\", \"myList.first(where: { $0 % 2 == 0 })\\n\", \"match(pattern: pattern).filter { $0.first == .identifier }\\n\", \"(myList.filter { $0 == 1 }.suffix(2)).first\\n\" ], //以下写法会触发警告 triggeringExamples: [ \"↓myList.filter { $0 % 2 == 0 }.first\\n\", \"↓myList.filter({ $0 % 2 == 0 }).first\\n\", \"↓myList.map { $0 + 1 }.filter({ $0 % 2 == 0 }).first\\n\", \"↓myList.map { $0 + 1 }.filter({ $0 % 2 == 0 }).first?.something()\\n\", \"↓myList.filter(someFunction).first\\n\", \"↓myList.filter({ $0 % 2 == 0 })\\n.first\\n\", \"(↓myList.filter { $0 == 1 }).first\\n\" ]) 规则35: for_where在for循环中,不建议使用单个if语句或者只使用一次循环变量,可使用where或者if{}else{}语句 识别码 默认是否启用 是否支持自动更正 类型 for_where 启用 no idiomatic 代码示例: 123456789101112131415161718192021222324252627//推荐写法for user in users where user.id == 1 { }for user in users { if let id = user.id { }}for user in users { if var id = user.id { }}for user in users { if user.id == 1 { } else { }}for user in users { if user.id == 1 { } print(user)}for user in users { let id = user.id if id == 1 { }}for user in users { if user.id == 1 &amp;&amp; user.age &gt; 18 { }}//不建议写法for user in users { if user.id == 1 { return true }} 规则36: force_cast不建议直接强解类型 识别码 默认是否启用 是否支持自动更正 类型 force_cast 启用 no idiomatic 代码示例: 12345//建议写法NSNumber() as? Int//不推荐NSNumber() ↓as! Int 规则37: force_try对会抛出异常(throws)的方法,不建议try!强解 识别码 默认是否启用 是否支持自动更正 类型 force_try 启用 no idiomatic 代码示例: 1234567891011func myFunction() throws { }/// 这样写是可以的，不会触发 errordo { try myFunction()} catch {}/// 这样直接触发 errortry! myFunction() 规则38: force_unwrapping强制解包/拆包。我们知道，当一个类型是可选类型的时候，当我们获取值时，需要强制解包（也叫隐式解包）, 通常我们是在一个变量或者所需要的常量、类型等后面加一个“ ！”， 然而，swiftlint建议强制解包应该要避免， 否则将给予warning 识别码 默认是否启用 是否支持自动更正 类型 force_unwrapping 未启用 no idiomatic 代码示例: 12345678910/// 将触发warningnavigationController!.pushViewController(myViewController, animated: true)let url = NSURL(string: \"http://www.baidu.com\")!print(url)return cell!/// 不会触发warningnavigationController?.pushViewController(myViewController, animated: true) 规则39: function_body_length函数体长度， 函数体不应该跨越太多行， 超过40行给warning， 超过100行直接报错 识别码 默认是否启用 是否支持自动更正 类型 function_body_length 启用 no metrics 规则40: function_parameter_count 函数参数个数， 函数参数数量(init方法除外)应该少点， 不要太多，swiftlint规定函数参数数量超过5个给warning， 超过8个直接报error 注：function_parameter_count: error 这样并不能改变它的警告或错误，该属性不允许修改，但是可以禁用 识别码 默认是否启用 是否支持自动更正 类型 function_parameter_count 启用 no metrics 规则41: generic_type_name泛型类型名称只能包含字母数字字符，以大写字母开头，长度介于1到20个字符之间 识别码 默认是否启用 是否支持自动更正 类型 generic_type_name 未启用 no idiomatic 代码示例: 1234567891011//推荐写法func foo&lt;T&gt;() {}func foo&lt;T&gt;() -&gt; T {}func foo&lt;T, U&gt;(param: U) -&gt; T {}func foo&lt;T: Hashable, U: Rule&gt;(param: U) -&gt; T {}//不推荐写法func foo&lt;T_Foo&gt;() {}func foo&lt;T, U_Foo&gt;(param: U_Foo) -&gt; T {}func foo&lt;TTTTTTTTTTTTTTTTTTTTT&gt;() {}func foo&lt;type&gt;() {} 规则42: identifier_name变量标识符名称应该只包含字母数字字符，并以小写字母开头或只应包含大写字母。在上述例外情况下，当变量名称被声明为静态且不可变时，变量名称可能以大写字母开头。变量名称不应该太长或太短 识别码 默认是否启用 是否支持自动更正 类型 identifier_name 启用 no style 官方给出的示例: 1234567891011121314151617181920212223242526272829303132internal struct IdentifierNameRuleExamples { //不会触发error static let nonTriggeringExamples = [ \"let myLet = 0\", \"var myVar = 0\", \"private let _myLet = 0\", \"class Abc { static let MyLet = 0 }\", \"let URL: NSURL? = nil\", \"let XMLString: String? = nil\", \"override var i = 0\", \"enum Foo { case myEnum }\", \"func isOperator(name: String) -&gt; Bool\", \"func typeForKind(_ kind: SwiftDeclarationKind) -&gt; String\", \"func == (lhs: SyntaxToken, rhs: SyntaxToken) -&gt; Bool\", \"override func IsOperator(name: String) -&gt; Bool\" ] //会触发error static let triggeringExamples = [ \"↓let MyLet = 0\", \"↓let _myLet = 0\", \"private ↓let myLet_ = 0\", \"↓let myExtremelyVeryVeryVeryVeryVeryVeryLongLet = 0\", \"↓var myExtremelyVeryVeryVeryVeryVeryVeryLongVar = 0\", \"private ↓let _myExtremelyVeryVeryVeryVeryVeryVeryLongLet = 0\", \"↓let i = 0\", \"↓var id = 0\", \"private ↓let _i = 0\", \"↓func IsOperator(name: String) -&gt; Bool\", \"enum Foo { case ↓MyEnum }\" ]} 规则44: implicit_getter对于只有只读属性不建议重写get方法 识别码 默认是否启用 是否支持自动更正 类型 implicit_getter 启用 no style 代码示例: 123456789101112131415161718192021222324252627282930313233343536373839404142//不会触发error//重写get和set方法class Foo { var foo: Int { get { return 3 } set { _abc = newValue } }}//只读class Foo { var foo: Int { return 20 } }class Foo { static var foo: Int { return 20 } }//会触发errorclass Foo { var foo: Int { get { return 20 } } }class Foo { var foo: Int { get{ return 20 } } } 规则45: implicit_return 建议使用隐式返回闭包; 如: foo.map({ $0 + 1 }) 识别码 默认是否启用 是否支持自动更正 类型 implicit_return 未启用 no style 代码示例: 123456789101112//推荐写法foo.map { $0 + 1 }foo.map({ $0 + 1 })foo.map { value in value + 1 }//不建议写法foo.map { value in return value + 1}foo.map { return $0 + 1} 规则46: implicitly_unwrapped_optional尽量避免隐式解析可选类型的使用 识别码 默认是否启用 是否支持自动更正 类型 implicitly_unwrapped_optional 未启用 no idiomatic 下面吗给出官方示例: 12345678910111213141516171819202122232425262728293031public static let description = RuleDescription( identifier: \"implicitly_unwrapped_optional\", name: \"Implicitly Unwrapped Optional\", description: \"Implicitly unwrapped optionals should be avoided when possible.\", kind: .idiomatic, //不会触发warning nonTriggeringExamples: [ \"@IBOutlet private var label: UILabel!\", \"@IBOutlet var label: UILabel!\", \"@IBOutlet var label: [UILabel!]\", \"if !boolean {}\", \"let int: Int? = 42\", \"let int: Int? = nil\" ], //会触发warning triggeringExamples: [ \"let label: UILabel!\", \"let IBOutlet: UILabel!\", \"let labels: [UILabel!]\", \"var ints: [Int!] = [42, nil, 42]\", \"let label: IBOutlet!\", \"let int: Int! = 42\", \"let int: Int! = nil\", \"var int: Int! = 42\", \"let int: ImplicitlyUnwrappedOptional&lt;Int&gt;\", \"let collection: AnyCollection&lt;Int!&gt;\", \"func foo(int: Int!) {}\" ]) 规则47: is_disjoint初始化集合Set时,推荐使用Set.isDisjoint(), 不建议:Set.intersection 识别码 默认是否启用 是否支持自动更正 类型 is_disjoint 启用 no idiomatic 代码示例: 123//推荐写法_ = Set(syntaxKinds).isDisjoint(with: commentAndStringKindsSet)let isObjc = !objcAttributes.isDisjoint(with: dictionary.enclosedSwiftAttributes) 规则48: joined_default_parameterjoined方法使用默认分隔符时, 建议使用joined()方法, 而不是joined(separator: “”)方法 识别码 默认是否启用 是否支持自动更正 类型 joined_default_parameter 未启用 yes idiomatic 代码示例: 12345678//建议写法let foo = bar.joined()let foo = bar.joined(separator: \",\")let foo = bar.joined(separator: toto)//不建议写法let foo = bar.joined(separator: \"\")let foo = bar.filter(toto).joined(separator: \"\") 规则49: large_tuple定义的元组成员个数,超过两个warning 识别码 默认是否启用 是否支持自动更正 类型 large_tuple 启用 no metrics 代码示例: 123456789//不会触发warninglet foo: (Int, Int)let foo: (start: Int, end: Int)let foo: (Int, (Int, String))//会触发warninglet foo: (Int, Int, Int)let foo: (start: Int, end: Int, value: String)let foo: (Int, (Int, Int, Int)) 规则50: leading_whitespace文件开始不应该有空格或者换行, 否则就会触发warning 识别码 默认是否启用 是否支持自动更正 类型 leading_whitespace 启用 yes style 代码示例: 123456789101112131415161718192021222324252627/// 不会触发warning//// ViewController.swift// SwiftLint//// Created by langke on 17/1/12.// Copyright © 2017年 langke. All rights reserved.///// 会触发warning //..................................这里有一个空格// ViewController.swift// SwiftLint//// Created by langke on 17/1/12.// Copyright © 2017年 langke. All rights reserved.///// 会触发warning......................................这里是一个空行//// ViewController.swift// SwiftLint//// Created by langke on 17/1/12.// Copyright © 2017年 langke. All rights reserved.// 参考文档SwiftLint规则官方文档SwiftLint个规则详细介绍 有些地方的解释和示例可能不是很完善, 希望各位大神多多指导,后续会持续更新中…….","link":"/2018/03/03/SwiftLint代码规范属性说明01/"}],"tags":[{"name":"Mac 工具","slug":"Mac-工具","link":"/tags/Mac-工具/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"框架","slug":"框架","link":"/tags/框架/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Realm","slug":"Realm","link":"/tags/Realm/"},{"name":"Objective-C","slug":"Objective-C","link":"/tags/Objective-C/"},{"name":"UIStackView","slug":"UIStackView","link":"/tags/UIStackView/"},{"name":"SwiftLint","slug":"SwiftLint","link":"/tags/SwiftLint/"},{"name":"规则","slug":"规则","link":"/tags/规则/"},{"name":"Homebrew","slug":"Homebrew","link":"/tags/Homebrew/"},{"name":"AppIcon","slug":"AppIcon","link":"/tags/AppIcon/"},{"name":"iOS 10.3","slug":"iOS-10-3","link":"/tags/iOS-10-3/"},{"name":"Swift4.0","slug":"Swift4-0","link":"/tags/Swift4-0/"},{"name":"Error","slug":"Error","link":"/tags/Error/"},{"name":"入坑","slug":"入坑","link":"/tags/入坑/"},{"name":"CocoaPods","slug":"CocoaPods","link":"/tags/CocoaPods/"},{"name":"pod","slug":"pod","link":"/tags/pod/"},{"name":"trunk","slug":"trunk","link":"/tags/trunk/"},{"name":"spec","slug":"spec","link":"/tags/spec/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Socket","slug":"Socket","link":"/tags/Socket/"},{"name":"WebSocket","slug":"WebSocket","link":"/tags/WebSocket/"},{"name":"Socket.IO","slug":"Socket-IO","link":"/tags/Socket-IO/"},{"name":"CoreAnimation","slug":"CoreAnimation","link":"/tags/CoreAnimation/"}],"categories":[{"name":"Swift高阶功能","slug":"Swift高阶功能","link":"/categories/Swift高阶功能/"},{"name":"数据库基础","slug":"数据库基础","link":"/categories/数据库基础/"},{"name":"iOS高阶功能","slug":"iOS高阶功能","link":"/categories/iOS高阶功能/"},{"name":"SwiftLint","slug":"SwiftLint","link":"/categories/SwiftLint/"},{"name":"Swift学习笔记","slug":"Swift学习笔记","link":"/categories/Swift学习笔记/"},{"name":"组件化开发","slug":"组件化开发","link":"/categories/组件化开发/"},{"name":"Hexo博客","slug":"Hexo博客","link":"/categories/Hexo博客/"},{"name":"Socket学习笔记","slug":"Socket学习笔记","link":"/categories/Socket学习笔记/"},{"name":"iOS动画","slug":"iOS动画","link":"/categories/iOS动画/"}]}